local redzlib = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/New-Gui/refs/heads/main/New-Redz.lua"))()

local Window = redzlib:MakeWindow({
  Title = "Hutao Hub [Free]",
  SubTitle = "by SLK Gaming",
  SaveFolder = "Hutao Hub - 99 Night.lua"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://90508203972003", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(0, 5) },
})

local TabDiscord = Window:MakeTab({"Discord", "info"})

local TabMain = Window:MakeTab({"Main", "home"})

local TabFarm = Window:MakeTab({"Farm", "gem"})

local TabPlayer = Window:MakeTab({"Player", "user"})

local TabItem = Window:MakeTab({"Items", "swords"})

local TabTeleport = Window:MakeTab({"Teleport", "locate"})

local TabVisual = Window:MakeTab({"Visual", "eye"})

local TabMisc = Window:MakeTab({"Misc", "menu"})

local TabSettings = Window:MakeTab({"Settings", "settings"})

---------------------------------------------------------------------------------
-- T·ªïng H·ª£p Logic
---------------------------------------------------------------------------------

task.spawn(function()
    repeat task.wait() until game:IsLoaded()

    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    -- ƒê·ª£i GUI c√¢u c√° xu·∫•t hi·ªán (kh√¥ng ch·∫∑n thread ch√≠nh)
    local Interface = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("Interface", 10)
    if not Interface then return end

    local FishingCatchFrame = Interface:FindFirstChild("FishingCatchFrame")
    if FishingCatchFrame and FishingCatchFrame:FindFirstChild("TimingBar") then
        local successArea = FishingCatchFrame.TimingBar:WaitForChild("SuccessArea", 5)
        if successArea then
            successArea:GetPropertyChangedSignal("Size"):Connect(function()
                pcall(function()
                    successArea.Position = UDim2.new(0.5, 0, 0, 0)
                    successArea.Size = UDim2.new(1, 0, 1, 0)
                end)
            end)
        end
    end
end)

-- üåç Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- üí° Thi·∫øt l·∫≠p √°nh s√°ng c∆° b·∫£n
Lighting.ClockTime = 14
Lighting.GlobalShadows = false






-- ======= FIXED & CLEANED BRING/ITEMS SCRIPT =======
-- Services & core refs (ƒë·∫∑t l√™n ƒë·∫ßu ƒë·ªÉ c√°c h√†m d√πng ƒë∆∞·ª£c ngay)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Item lists (ƒë√£ lo·∫°i tr√πng l·∫∑p v√† s·ª≠a d·∫•u ph·∫©y / quotes)
local ie = {
    "Bandage", "Bolt", "Broken Fan", "Broken Microwave", "Cake", "Carrot", "Chair", "Coal", "Coin Stack",
    "Cooked Morsel", "Cooked Steak", "Fuel Canister", "Iron Body", "Leather Armor", "Log", "MadKit", "Metal Chair",
    "MedKit", "Old Car Engine", "Old Flashlight", "Old Radio", "Revolver", "Revolver Ammo", "Rifle", "Rifle Ammo",
    "Morsel", "Sheet Metal", "Steak", "Tyre", "Washing Machine", "Cultist Gem", "Gem of the Forest Fragment", "Frozen Shuriken",
    "Tactical Shotgun", "Snowball", "Kunai"
}

local me = {
    "Bunny", "Wolf", "Alpha Wolf", "Bear", "Crossbow Cultist", "Alien", "Alien Elite", "Polar Bear",
    "Arctic Fox", "Mammoth", "Cultist", "Cultist Melee", "Cultist Crossbow", "Cultist Juggernaut"
}

-- Bring categories
local BlueprintItems = {"Crafting Blueprint", "Defense Blueprint", "Furniture Blueprint"}
local selectedBlueprintItems = {}
local PeltsItems = {"Bunny Foot", "Wolf Pelt", "Alpha Wolf Pelt", "Bear Pelt", "Arctic Fox Pelt", "Polar Bear Pelt"}
local selectedPeltsItems = {}
local junkItems = {
    "Bolt", "Sheet Metal", "UFO Junk", "UFO Component", "Broken Fan", "Old Radio",
    "Broken Microwave", "Tyre", "Metal Chair", "Old Car Engine", "Washing Machine",
    "Cultist Experiment", "Cultist Prototype", "UFO Scrap", "Cultist Gem",
    "Gem of the Forest Fragment", "Feather", "Old Boot"
}
local selectedJunkItems = {}
local fuelItems = {"Log", "Chair", "Coal", "Fuel Canister", "Oil Barrel"}
local selectedFuelItems = {}

local foodItems = {
    "Cake", "Cooked Steak", "Cooked Morsel", "Ribs", "Salmon", "Cooked Salmon",
    "Cooked Ribs", "Mackerel", "Cooked Mackerel", "Steak", "Morsel", "Berry",
    "Carrot", "Stew", "Hearty Stew", "Corn", "Pumpkin", "Meat? Sandwich",
    "Seafood Chowder", "Steak Dinner", "Pumpkin Soup", "BBQ Ribs", "Carrot Cake",
    "Jar o' Jelly", "Clownfish", "Swordfish", "Jellyfish", "Char", "Eel", "Shark",
    "Cooked Clownfish", "Cooked Swordfish", "Cooked Jellyfish",
    "Cooked Char", "Cooked Eel", "Cooked Shark"
}
local selectedFoodItems = {}

local medicalItems = {"Bandage", "MedKit"}
local selectedMedicalItems = {}
local equipmentItems = {
    "Revolver", "Rifle", "Revolver Ammo", "Rifle Ammo", "Giant Sack", "Good Sack",
    "Strong Axe", "Good Axe", "Frozen Shuriken", "Tactical Shotgun", "Snowball", "Kunai",
    "Leather Body", "Poison Armour", "Iron Body", "Thorn Body", "Riot Shield", "Alien Armour",
    "Red Key", "Blue Key", "Yellow Key", "Grey Key", "Frog Key", "Chili Seeds",
    "Flower Seeds", "Berry Seeds", "Firefly Seeds", "Old Rod", "Good Rod", "Strong Rod"
}
local selectedEquipmentItems = {}

-- State variables
local isCollecting = false
local originalPosition = nil
local autoBringEnabled = false

-- Toggle states for each category
local BlueprintToggleEnabled = false
local PeltsToggleEnabled = false
local junkToggleEnabled = false
local fuelToggleEnabled = false
local foodToggleEnabled = false
local medicalToggleEnabled = false
local equipmentToggleEnabled = false

-- Loop control flags
local BlueprintLoopRunning = false
local PeltsLoopRunning = false
local junkLoopRunning = false
local fuelLoopRunning = false
local foodLoopRunning = false
local medicalLoopRunning = false
local equipmentLoopRunning = false

-- Enhanced smooth pulling movement with easing
-- startCFrame and endCFrame are CFrame values
local function smoothPullToItem(startCFrame, endCFrame, duration)
    if not startCFrame or not endCFrame or duration <= 0 then
        return
    end

    local player = Players.LocalPlayer
    if not player or not player.Character then return end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local startTime = tick()
    spawn(function()
        while tick() - startTime < duration do
            if not hrp then break end
            local elapsed = tick() - startTime
            local progress = math.clamp(elapsed / duration, 0, 1)

            -- Ease-in-out
            local easedProgress
            if progress < 0.5 then
                easedProgress = 2 * progress * progress
            else
                easedProgress = 1 - math.pow(-2 * progress + 2, 2) / 2
            end

            local currentPos = startCFrame.Position:Lerp(endCFrame.Position, easedProgress)
            local lookDirection = endCFrame.Position - currentPos

            if lookDirection.Magnitude > 0 then
                hrp.CFrame = CFrame.lookAt(currentPos, currentPos + lookDirection.Unit)
            else
                hrp.CFrame = CFrame.new(currentPos)
            end

            task.wait()
        end

        -- final snap
        if hrp then
            hrp.CFrame = endCFrame
        end
    end)

    task.wait(duration)
end

-- Enhanced item pulling effect (itemPart is BasePart)
local function createItemPullEffect(itemPart, targetPos, duration)
    if not itemPart or not itemPart.Parent or duration <= 0 then return end

    local startPos = itemPart.Position
    local startTime = tick()

    spawn(function()
        while tick() - startTime < duration do
            if not itemPart or not itemPart.Parent then break end
            local elapsed = tick() - startTime
            local progress = math.clamp(elapsed / duration, 0, 1)

            -- ease-out cubic
            local easedProgress = 1 - math.pow(1 - progress, 3)

            local currentPos = Vector3.new(
                startPos.X + (targetPos.X - startPos.X) * easedProgress,
                startPos.Y + (targetPos.Y - startPos.Y) * easedProgress,
                startPos.Z + (targetPos.Z - startPos.Z) * easedProgress
            )

            pcall(function()
                itemPart.CFrame = CFrame.new(currentPos)
                if itemPart:FindFirstChild("Velocity") == nil then
                    itemPart.Velocity = Vector3.new(0, 0, 0)
                else
                    itemPart.Velocity = Vector3.new(0, 0, 0)
                end
                itemPart.RotVelocity = Vector3.new(0, 0, 0)
            end)

            task.wait()
        end

        -- final
        pcall(function()
            itemPart.CFrame = CFrame.new(targetPos)
            itemPart.Velocity = Vector3.new(0, 0, 0)
            itemPart.RotVelocity = Vector3.new(0, 0, 0)
        end)
    end)

    task.wait(duration)
end

-- Enhanced bypass bring system with smooth pulling (no noclip)
-- items: table of item names
-- stopFlag: function that returns true to continue, false to stop (optional)
local function bypassBringSystem(items, stopFlag)
    if isCollecting then
        return
    end

    isCollecting = true
    local player = Players.LocalPlayer
    if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        isCollecting = false
        return
    end

    local hrp = player.Character.HumanoidRootPart
    originalPosition = hrp.CFrame

    for _, itemName in ipairs(items) do
        if stopFlag and not stopFlag() then
            break
        end

        local itemsFound = {}

        -- Find items (search Workspace descendants)
        for _, item in ipairs(Workspace:GetDescendants()) do
            if item.Name == itemName and (item:IsA("BasePart") or item:IsA("Model")) then
                local itemPart = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")) or item
                if itemPart and itemPart.Parent ~= player.Character then
                    table.insert(itemsFound, {item = item, part = itemPart})
                end
            end
        end

        for _, itemData in ipairs(itemsFound) do
            if stopFlag and not stopFlag() then
                break
            end

            local item = itemData.item
            local itemPart = itemData.part

            if itemPart and itemPart.Parent then
                -- Step 1: Smooth pull player to just above the item
                local itemPosCFrame = itemPart.CFrame + Vector3.new(0, 5, 0)
                smoothPullToItem(hrp.CFrame, itemPosCFrame, 1.2)

                -- Step 2: Pull item to player (magnetic)
                local playerTargetPos = hrp.Position + Vector3.new(0, -1, 0)
                createItemPullEffect(itemPart, playerTargetPos, 0.8)

                -- Step 3: Keep item attached visually while returning
                local keepAttached = true
                local attachThread
                attachThread = spawn(function()
                    while keepAttached do
                        if stopFlag and not stopFlag() then
                            keepAttached = false
                            break
                        end
                        if itemPart and itemPart.Parent and hrp and hrp.Parent then
                            pcall(function()
                                local offset = Vector3.new(
                                    math.sin(tick() * 2) * 0.5,
                                    -1 + math.cos(tick() * 3) * 0.2,
                                    math.cos(tick() * 2) * 0.5
                                )
                                itemPart.CFrame = CFrame.new(hrp.Position + offset)
                                itemPart.Velocity = Vector3.new(0, 0, 0)
                                itemPart.RotVelocity = Vector3.new(0, 0, 0)
                            end)
                        end
                        task.wait(0.03)
                    end
                end)

                -- Smooth return to original position
                smoothPullToItem(hrp.CFrame, originalPosition, 1.0)

                -- Stop attachment and gently drop item near original
                keepAttached = false
                task.wait(0.1)

                pcall(function()
                    local landingPos = originalPosition.Position + Vector3.new(
                        math.random(-4, 4),
                        2,
                        math.random(-4, 4)
                    )
                    createItemPullEffect(itemPart, landingPos, 0.5)
                end)
            end

            task.wait(0.5)
        end
    end

    -- Ensure player returned
    if originalPosition and LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = originalPosition
    end

    isCollecting = false
end

-- Added new scrap logic variables
local scrapjunkItems = {
    "Log", "Chair", "Tyre", "Bolt", "Broken Fan", "Broken Microwave", "Sheet Metal",
    "Old Radio", "Washing Machine", "Old Car Engine", "Cultist Gem", "Gem of the Forest Fragment"
}
local autoScrapPos = Vector3.new(21, 20, -5)
local selectedScrapItem = nil
local autoScrapItemsEnabled = false

-- Utility functions (use proper global refs)
local function wiki(nome)
    local c = 0
    local itemsFolder = Workspace:FindFirstChild("Items")
    if not itemsFolder then return 0 end
    for _, i in ipairs(itemsFolder:GetChildren()) do
        if i.Name == nome then
            c = c + 1
        end
    end
    return c
end

local function ghn()
    if not LocalPlayer or not LocalPlayer.PlayerGui then return 100 end
    local bar = LocalPlayer.PlayerGui:FindFirstChild("Interface") and LocalPlayer.PlayerGui.Interface:FindFirstChild("StatBars")
    if not bar or not bar:FindFirstChild("HungerBar") or not bar.HungerBar:FindFirstChild("Bar") then
        return 100
    end
    return math.floor(bar.HungerBar.Bar.Size.X.Scale * 100)
end

local function feed(nome)
    local itemsFolder = Workspace:FindFirstChild("Items")
    if not itemsFolder then return end
    for _, item in ipairs(itemsFolder:GetChildren()) do
        if item.Name == nome then
            pcall(function()
                local remote = ReplicatedStorage:WaitForChild("RemoteEvents")
                if remote and remote.RequestConsumeItem then
                    remote.RequestConsumeItem:InvokeServer(item)
                end
            end)
            break
        end
    end
end

-- Function to teleport player to item, pick it up, then return with item
-- itemNames: table of names
-- originalPosition: CFrame or Vector3 (if Vector3 passed, will be converted)
local function bringItemsByPlayerTP(itemNames, originalPosition)
    if not LocalPlayer or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local hrp = LocalPlayer.Character.HumanoidRootPart
    local itemsFound = {}

    -- Normalize originalPosition to CFrame
    local origCFrame
    if typeof(originalPosition) == "CFrame" then
        origCFrame = originalPosition
    elseif typeof(originalPosition) == "Vector3" then
        origCFrame = CFrame.new(originalPosition)
    else
        origCFrame = hrp.CFrame
    end

    -- Collect matches
    for _, itemName in ipairs(itemNames) do
        for _, item in ipairs(Workspace:GetDescendants()) do
            if item.Name == itemName and (item:IsA("BasePart") or item:IsA("Model")) then
                local part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")) or item
                if part and part:IsA("BasePart") then
                    table.insert(itemsFound, {item = item, part = part})
                end
            end
        end
    end

    -- Process found items
    for _, itemData in ipairs(itemsFound) do
        local item = itemData.item
        local part = itemData.part

        if item and item.Parent and part then
            -- Teleport to item (slightly above)
            local itemPosition = part.Position + Vector3.new(0, 3, 0)
            hrp.CFrame = CFrame.new(itemPosition)
            task.wait(0.2)

            -- Start dragging server event
            pcall(function()
                local remote = ReplicatedStorage:FindFirstChild("RemoteEvents")
                if remote and remote.RequestStartDraggingItem then
                    remote.RequestStartDraggingItem:FireServer(item)
                end
            end)

            task.wait(0.3)

            -- Teleport back to original
            hrp.CFrame = origCFrame
            task.wait(0.2)

            -- Stop dragging
            pcall(function()
                local remote = ReplicatedStorage:FindFirstChild("RemoteEvents")
                if remote and remote.StopDraggingItem then
                    remote.StopDraggingItem:FireServer(item)
                end
            end)

            task.wait(0.5)
        end
    end

    -- Ensure player returned
    if origCFrame and LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = origCFrame
    end
end

-- ======= End of fixed script =======



---------------------------------------------------------------------------------
-- Ph·∫ßn Discord
---------------------------------------------------------------------------------

TabDiscord:AddDiscordInvite({
    Name = "Hutao Hub [Free] | Community",
    Description = "Tham gia nh√≥m discord ƒë·ªÉ nh·∫≠n th√¥ng b√°o update m·ªõi",
    Logo = "rbxassetid://90508203972003",
    Invite = "https://discord.gg/8pAYYvAJC",
})


---------------------------------------------------------------------------------
-- Ph·∫ßn Main
---------------------------------------------------------------------------------


-- ‚öîÔ∏è COMBAT SYSTEM (FULL MERGED VERSION: KILL AURA + CHOP AURA)
-----------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer

-- ‚öôÔ∏è Bi·∫øn ƒëi·ªÅu khi·ªÉn ch√≠nh
local scan_map = false
local killAuraToggle = false
local chopAuraToggle = false
local auraRadius = 50
local currentAmount = 0

-- ü™ì ID damage theo tool
local toolsDamageIDs = {
    ["Old Axe"] = "3_7367831688",
    ["Good Axe"] = "112_7367831688",
    ["Strong Axe"] = "116_7367831688",
    ["Ice Axe"] = "116_7367831688",
    ["Admin Axe"] = "116_7367831688",
    ["Morningstar"] = "116_7367831688",
    ["Laser Sword"] = "116_7367831688",
    ["Ice Sword"] = "116_7367831688",
    ["Katana"] = "116_7367831688",
    ["Trident"] = "116_7367831688",
    ["Poison Spear"] = "116_7367831688",
    ["Chainsaw"] = "647_8992824875",
    ["Spear"] = "196_8999010016"
}

-- ‚öîÔ∏è L·∫•y damage ID theo t√™n tool
local function getToolDamageID(toolName)
    return toolsDamageIDs[toolName] or nil
end

-- üß≠ H√†m qu√©t m·ª•c ti√™u (placeholder)
local function scanForTargets()
    if not scan_map then return end
end

-- üîÅ Toggle state
local function toggleKillAura(state)
    killAuraToggle = state
end

local function toggleChopAura(state)
    chopAuraToggle = state
end

-- üß§ Equip / Unequip tool
local function equipTool(tool)
    if tool then
        ReplicatedStorage:WaitForChild("RemoteEvents").EquipItemHandle:FireServer("FireAllClients", tool)
    end
end

local function unequipTool(tool)
    if tool then
        ReplicatedStorage:WaitForChild("RemoteEvents").UnequipItemHandle:FireServer("FireAllClients", tool)
    end
end

-- üí´ H√†m l·∫•y tool c√≥ th·ªÉ g√¢y damage
local function getAnyToolWithDamageID(isChopAura)
    for toolName, damageID in pairs(toolsDamageIDs) do
        if isChopAura and toolName ~= "Old Axe" and toolName ~= "Good Axe" and toolName ~= "Strong Axe" 
        and toolName ~= "Ice Axe" and toolName ~= "Chainsaw" then
            continue
        end
        local tool = LocalPlayer:FindFirstChild("Inventory") and LocalPlayer.Inventory:FindFirstChild(toolName)
        if tool then
            return tool, damageID
        end
    end
    return nil, nil
end

-----------------------------------------------------------
-- ‚öîÔ∏è KILL AURA (T·ª± ƒë·ªông ƒë√°nh qu√°i)
-----------------------------------------------------------
local function killAuraLoop()
    while killAuraToggle do
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local tool, damageID = getAnyToolWithDamageID(false)
            if tool and damageID then
                equipTool(tool)
                for _, mob in ipairs(Workspace.Characters:GetChildren()) do
                    if mob:IsA("Model") and mob ~= character then
                        local part = mob:FindFirstChildWhichIsA("BasePart")
                        if part and (part.Position - hrp.Position).Magnitude <= auraRadius then
                            pcall(function()
                                ReplicatedStorage:WaitForChild("RemoteEvents").ToolDamageObject:InvokeServer(
                                    mob,
                                    tool,
                                    damageID,
                                    CFrame.new(part.Position)
                                )
                            end)
                        end
                    end
                end
                task.wait(0.1)
            else
                task.wait(1)
            end
        else
            task.wait(0.5)
        end
    end
end

-----------------------------------------------------------
-- üå≥ CHOP AURA (T·ª± ƒë·ªông ch·∫∑t c√¢y, ƒë√°...)
-----------------------------------------------------------
local function chopAuraLoop()
    while chopAuraToggle do
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local tool, baseDamageID = getAnyToolWithDamageID(true)
            if tool and baseDamageID then
                equipTool(tool)
                currentAmount = currentAmount + 1
                local trees = {}
                local map = Workspace:FindFirstChild("Map")

                -- ü™µ Qu√©t to√†n b·ªô c√¢y trong Map
                if map then
                    if map:FindFirstChild("Foliage") then
                        for _, obj in ipairs(map.Foliage:GetChildren()) do
                            if obj:IsA("Model") and (obj.Name == "Small Tree" or obj.Name == "Snowy Small Tree") then
                                table.insert(trees, obj)
                            end
                        end
                    end
                    if map:FindFirstChild("Landmarks") then
                        for _, obj in ipairs(map.Landmarks:GetChildren()) do
                            if obj:IsA("Model") and obj.Name == "Small Tree" then
                                table.insert(trees, obj)
                            end
                        end
                    end
                end

                -- üî® T·∫•n c√¥ng t·ª´ng c√¢y g·∫ßn ng∆∞·ªùi ch∆°i
                for _, tree in ipairs(trees) do
                    local trunk = tree:FindFirstChild("Trunk")
                    if trunk and trunk:IsA("BasePart") and (trunk.Position - hrp.Position).Magnitude <= auraRadius then
                        local alreadyHit = false
                        task.spawn(function()
                            while chopAuraToggle and tree and tree.Parent and not alreadyHit do
                                alreadyHit = true
                                currentAmount = currentAmount + 1
                                pcall(function()
                                    ReplicatedStorage:WaitForChild("RemoteEvents").ToolDamageObject:InvokeServer(
                                        tree,
                                        tool,
                                        tostring(currentAmount) .. "_7367831688",
                                        CFrame.new(-2.96, 4.55, -75.95, 0.8962, 0, 0.4436, 0, 1, 0, -0.4436, 0, 0.8962)
                                    )
                                end)
                                task.wait(0.5)
                            end
                        end)
                    end
                end
                task.wait(0.1)
            else
                task.wait(1)
            end
        else
            task.wait(0.5)
        end
    end
end

-----------------------------------------------------------
-- üåÄ LOOP CHUNG (n·∫øu c·∫ßn th√™m scan logic)
-----------------------------------------------------------
RunService.Heartbeat:Connect(function()
    if killAuraToggle or chopAuraToggle then
        scanForTargets()
    end
end)

-----------------------------------------------------------
-- üß† TOGGLE GUI
-----------------------------------------------------------
TabMain:AddToggle({
    Name = "Kill Aura",
    Description = "T·ª± ƒë·ªông t·∫•n c√¥ng qu√°i v·∫≠t xung quanh b·∫±ng v≈© kh√≠ chi·∫øn ƒë·∫•u",
    Default = _G.KillAura or false,
    Callback = function(Value)
        _G.KillAura = Value
        toggleKillAura(Value)
        if Value then
            task.spawn(killAuraLoop)
        else
            local tool, _ = getAnyToolWithDamageID(false)
            unequipTool(tool)
        end
    end
})

TabMain:AddToggle({
    Name = "Chop Aura",
    Description = "T·ª± ƒë·ªông ch·∫∑t c√¢y, ƒë√° ho·∫∑c t√†i nguy√™n g·∫ßn b·∫°n",
    Default = _G.ChopAura or false,
    Callback = function(Value)
        _G.ChopAura = Value
        toggleChopAura(Value)
        if Value then
            task.spawn(chopAuraLoop)
        else
            local tool, _ = getAnyToolWithDamageID(true)
            unequipTool(tool)
        end
    end
})



-- üìè Aura Radius Slider (chu·∫©n Fluent GUI)
TabMain:AddSlider({
    Name = "Aura Radius",
    Description = "ƒêi·ªÅu ch·ªânh ph·∫°m vi t·∫•n c√¥ng t·ª± ƒë·ªông c·ªßa Kill Aura v√† Chop Aura",
    Min = 20,
    Max = 800,
    Default = _G.AuraRadius or 50,
    Callback = function(Value)
        auraRadius = math.clamp(Value, 10, 800)
        _G.AuraRadius = auraRadius
    end
})


local Section = TabMain:AddSection({"Plant"})


-- üå± AUTO PLANT SYSTEM (FULL MERGED VERSION)
------------------------------------------------------

-- ‚öôÔ∏è Bi·∫øn v√† h√†m ch√≠nh
local AutoPlantToggle = _G.AutoPlant or false

-- üìç V·ªã tr√≠ tr·ªìng c√¢y (c√≥ th·ªÉ thay ƒë·ªïi)
local plantPosition = Vector3.new(-41.2053, 1.0633, 29.2236)

-- ü™¥ H√†m auto plant
local function autoplant()
    while AutoPlantToggle do
        local success, err = pcall(function()
            local args = {
                Instance.new("Model"), -- placeholder item
                plantPosition
            }

            local remote = game:GetService("ReplicatedStorage")
                :WaitForChild("RemoteEvents")
                :WaitForChild("RequestPlantItem", 5) -- timeout 5s

            if remote then
                remote:InvokeServer(unpack(args))
            else
                warn("[AutoPlant] Remote RequestPlantItem not found.")
            end
        end)

        if not success then
            warn("[AutoPlant Error]:", err)
        end

        task.wait(1) -- delay gi·ªØa m·ªói l·∫ßn tr·ªìng
    end
end

------------------------------------------------------
-- üå± GUI Toggle
TabMain:AddToggle({
    Name = "Auto Plant",
    Description = "T·ª± ƒë·ªông tr·ªìng c√¢y ho·∫∑c t√†i nguy√™n khi c√≥ h·∫°t gi·ªëng trong t√∫i",
    Default = AutoPlantToggle,
    Callback = function(Value)
        _G.AutoPlant = Value
        AutoPlantToggle = Value

        if Value then
            task.spawn(autoplant)
        end
    end
})




---------------------------------------------------------------------------------
-- Ph·∫ßn Farm
---------------------------------------------------------------------------------




---------------------------------------------------------------------------------
-- Ph·∫ßn Player
---------------------------------------------------------------------------------

-- üåü N√∫t ƒêi Xuy√™n T∆∞·ªùng (NoClip)
TabPlayer:AddToggle({
    Name = "Noclip",
    Description = "Cho ph√©p nh√¢n v·∫≠t ƒëi xuy√™n qua m·ªçi v·∫≠t th·ªÉ",
    Default = false,
    Callback = function(Value)
        _G.NoClip = Value
        
        if Value then
            -- B·∫≠t NoClip
            task.spawn(function()
                local player = game.Players.LocalPlayer
                local char = player.Character or player.CharacterAdded:Wait()

                while _G.NoClip and task.wait() do
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            -- T·∫Øt NoClip -> b·∫≠t l·∫°i va ch·∫°m
            local player = game.Players.LocalPlayer
            local char = player.Character
            if char then
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
})



local UserInputService = game:GetService("UserInputService")
_G.InfJump = false

TabPlayer:AddToggle({
    Name = "Infinite Jump",
    Description = "Cho ph√©p nh·∫£y kh√¥ng gi·ªõi h·∫°n gi·ªØa kh√¥ng trung",
    Default = false,
    Callback = function(Value)
        _G.InfJump = Value
    end
})

UserInputService.JumpRequest:Connect(function()
    if _G.InfJump then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChildOfClass("Humanoid") then
            char:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
        end
    end
end)


local Section = TabPlayer:AddSection({"Bypass"})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RequestConsumeItem = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestConsumeItem")

local infHungerActive = false
local infHungerConn

TabPlayer:AddToggle({
    Name = "Inf Hunger",
    Description = "Gi·ªØ ch·ªâ s·ªë Hunger lu√¥n ƒë·∫ßy (ch·ªëng ƒë√≥i)",
    Default = false,
    Callback = function(state)
        infHungerActive = state

        if state then
            print("[üçó] Inf Hunger: ON")

            infHungerConn = task.spawn(function()
                while infHungerActive do
                    pcall(function()
                        RequestConsumeItem:InvokeServer(Instance.new("Model"))
                    end)
                    task.wait(1)
                end
            end)

        else
            print("[üõë] Inf Hunger: OFF")

            if infHungerConn then
                task.cancel(infHungerConn)
                infHungerConn = nil
            end
        end
    end
})



local Section = TabPlayer:AddSection({"Speed"})


-- ‚ö°Ô∏è N√∫t B·∫≠t/T·∫Øt + Thanh Tr∆∞·ª£t T·ªëc ƒê·ªô Ch·∫°y
_G.WalkSpeedEnabled = false
_G.WalkSpeed = 16 -- m·∫∑c ƒë·ªãnh Roblox

-- üü¢ Toggle b·∫≠t/t·∫Øt tƒÉng t·ªëc ƒë·ªô
TabPlayer:AddToggle({
    Name = "Walk Speed",
    Description = "B·∫≠t ƒë·ªÉ thay ƒë·ªïi t·ªëc ƒë·ªô di chuy·ªÉn theo thanh tr∆∞·ª£t",
    Default = false,
    Callback = function(Value)
        _G.WalkSpeedEnabled = Value

        local player = game.Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local humanoid = char:FindFirstChildOfClass("Humanoid")

        if Value then
            -- B·∫≠t tƒÉng t·ªëc
            task.spawn(function()
                while _G.WalkSpeedEnabled and task.wait(0.1) do
                    if humanoid then
                        humanoid.WalkSpeed = _G.WalkSpeed or 16
                    end
                end
            end)
        else
            -- T·∫Øt tƒÉng t·ªëc -> v·ªÅ m·∫∑c ƒë·ªãnh
            if humanoid then
                humanoid.WalkSpeed = 16
            end
        end
    end
})

-- üéöÔ∏è Slider ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô
TabPlayer:AddSlider({
    Name = "You Speed",
    Description = "ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô nh√¢n v·∫≠t (1‚Äì500)",
    Min = 1,
    Max = 500,
    Default = 16,
    Callback = function(Value)
        _G.WalkSpeed = Value
        local player = game.Players.LocalPlayer
        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")

        if _G.WalkSpeedEnabled and humanoid then
            humanoid.WalkSpeed = Value
        end
    end
})

-- üîÅ Gi·ªØ t·ªëc ƒë·ªô sau khi respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
    repeat task.wait() until char:FindFirstChildOfClass("Humanoid")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if _G.WalkSpeedEnabled and humanoid then
        humanoid.WalkSpeed = _G.WalkSpeed
    end
end)




local Section = TabPlayer:AddSection({"Jump"})


-- ü¶ò N√∫t B·∫≠t/T·∫Øt + Thanh Tr∆∞·ª£t Nh·∫£y Cao
_G.JumpPowerEnabled = false
_G.JumpPower = 50 -- m·∫∑c ƒë·ªãnh c·ªßa Roblox

-- üü¢ Toggle b·∫≠t/t·∫Øt nh·∫£y cao
TabPlayer:AddToggle({
    Name = "Jump Power",
    Description = "B·∫≠t ƒë·ªÉ ƒëi·ªÅu ch·ªânh ƒë·ªô cao khi nh·∫£y",
    Default = false,
    Callback = function(Value)
        _G.JumpPowerEnabled = Value

        local player = game.Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local humanoid = char:FindFirstChildOfClass("Humanoid")

        if Value then
            -- B·∫≠t nh·∫£y cao
            task.spawn(function()
                while _G.JumpPowerEnabled and task.wait(0.1) do
                    if humanoid then
                        humanoid.UseJumpPower = true
                        humanoid.JumpPower = _G.JumpPower or 50
                    end
                end
            end)
        else
            -- T·∫Øt nh·∫£y cao -> v·ªÅ m·∫∑c ƒë·ªãnh
            if humanoid then
                humanoid.JumpPower = 50
            end
        end
    end
})

-- üéöÔ∏è Slider ƒëi·ªÅu ch·ªânh ƒë·ªô cao khi nh·∫£y
TabPlayer:AddSlider({
    Name = "Power",
    Description = "ƒêi·ªÅu ch·ªânh ƒë·ªô cao khi b·∫≠t 'Nh·∫£y Cao' (1‚Äì500)",
    Min = 1,
    Max = 500,
    Default = 50,
    Callback = function(Value)
        _G.JumpPower = Value
        local player = game.Players.LocalPlayer
        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")

        if _G.JumpPowerEnabled and humanoid then
            humanoid.JumpPower = Value
        end
    end
})

-- üîÅ Gi·ªØ ƒë·ªô cao nh·∫£y sau khi respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
    repeat task.wait() until char:FindFirstChildOfClass("Humanoid")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if _G.JumpPowerEnabled and humanoid then
        humanoid.JumpPower = _G.JumpPower
    end
end)




local Section = TabPlayer:AddSection({"Flying"})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ‚öôÔ∏è STATE
local flying = false
local flySpeed = 50
local renderConn

----------------------------------------------------
-- üß© BODY MOVERS (Gi·ªØ cho nh√¢n v·∫≠t bay ·ªïn ƒë·ªãnh)
----------------------------------------------------
local function attachBodyMovers(character)
	local humanoid = character:WaitForChild("Humanoid")
	local HRP = character:WaitForChild("HumanoidRootPart")

	if HRP:FindFirstChild("BodyVelocity") then HRP.BodyVelocity:Destroy() end
	if HRP:FindFirstChild("BodyGyro") then HRP.BodyGyro:Destroy() end

	local bv = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
	bv.Velocity = Vector3.zero
	bv.Name = "BodyVelocity"
	bv.Parent = HRP

	local bg = Instance.new("BodyGyro")
	bg.MaxTorque = Vector3.new(1e6, 1e6, 1e6)
	bg.CFrame = HRP.CFrame
	bg.Name = "BodyGyro"
	bg.Parent = HRP

	humanoid:ChangeState(Enum.HumanoidStateType.Physics)

	return bv, bg
end

----------------------------------------------------
-- üïäÔ∏è START/STOP FLY
----------------------------------------------------
local function startFlying()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	if humanoid.Health <= 0 then return end
	local HRP = character:WaitForChild("HumanoidRootPart")
	local bv, bg = attachBodyMovers(character)

	renderConn = RunService.RenderStepped:Connect(function()
		if not flying or humanoid.Health <= 0 then return end
		local moveDir = humanoid.MoveDirection
		local camCF = Camera.CFrame
		local moveVec = Vector3.zero

		if moveDir.Magnitude > 0 then
			local forward = camCF.LookVector
			local flatForward = Vector3.new(forward.X, 0, forward.Z).Unit
			local verticalInfluence = forward.Unit.Y

			local movingForward = flatForward:Dot(moveDir.Unit) > 0.1
			local movingBackward = flatForward:Dot(moveDir.Unit) < -0.1

			local yVelocity = 0
			if movingForward then 
				yVelocity = verticalInfluence
			elseif movingBackward then 
				yVelocity = -verticalInfluence 
			end

			moveVec = Vector3.new(moveDir.X, yVelocity, moveDir.Z).Unit
		end

		if bv and bg then
			bv.Velocity = moveVec * flySpeed
			bg.CFrame = camCF
		end
	end)

	flying = true
end

local function stopFlying()
	flying = false
	if renderConn then renderConn:Disconnect() renderConn = nil end

	local character = player.Character
	if character then
		local HRP = character:FindFirstChild("HumanoidRootPart")
		if HRP then
			if HRP:FindFirstChild("BodyVelocity") then HRP.BodyVelocity:Destroy() end
			if HRP:FindFirstChild("BodyGyro") then HRP.BodyGyro:Destroy() end
		end

		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		end
	end
end

-- üîÅ Gi·ªØ tr·∫°ng th√°i khi respawn
player.CharacterAdded:Connect(function()
	task.wait(0.5)
	if flying then
		startFlying()
	end
end)

----------------------------------------------------
-- üß† GUI SETUP
----------------------------------------------------
TabPlayer:AddToggle({
	Name = "Fly (Mobile + PC)",
	Description = "Ch·∫ø ƒë·ªô bay (h·ªó tr·ª£ c·∫£ PC & Mobile)",
	Default = false,
	Callback = function(value)
		if value then
			startFlying()
		else
			stopFlying()
		end
	end
})

TabPlayer:AddSlider({
	Name = "Fly Speed",
	Description = "ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô bay",
	Min = 10,
	Max = 300,
	Default = flySpeed,
	Callback = function(value)
		flySpeed = value
	end
})








---------------------------------------------------------------------------------
-- Ph·∫ßn Item
---------------------------------------------------------------------------------

TabItem:AddButton({
    Name = "Bring Everything",
    Description = "H√∫t to√†n b·ªô item trong map v·ªÅ quanh b·∫°n",
    Callback = function()
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local itemsFolder = workspace:FindFirstChild("Items")
        if not itemsFolder then
            warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c Items trong workspace.")
            return
        end

        for _, item in ipairs(itemsFolder:GetChildren()) do
            local part = item:FindFirstChildWhichIsA("BasePart") or (item:IsA("BasePart") and item)
            if part then
                -- H√∫t ƒë·ªì v·ªÅ quanh ng∆∞·ªùi, c√≥ ng·∫´u nhi√™n ƒë·ªÉ tr√°nh ch·ªìng
                part.CFrame = hrp.CFrame + Vector3.new(math.random(-7, 7), 0, math.random(-7, 7))
                task.wait(0.01) -- gi√∫p gi·∫£m lag
            end
        end
    end
})



local Section = TabItem:AddSection({"Medicine"})


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch v·∫≠t ph·∫©m mu·ªën t·∫°o n√∫t Bring
local medicalItems = {"Bandage", "MedKit"}

-- T·∫°o n√∫t Bring cho t·ª´ng v·∫≠t ph·∫©m (theo ki·ªÉu Fluent)
for _, itemName in ipairs(medicalItems) do
    TabItem:AddButton({
        Name = "Bring " .. itemName,
        Description = "H√∫t to√†n b·ªô v·∫≠t ph·∫©m '" .. itemName .. "' v·ªÅ quanh b·∫°n",
        Callback = function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")

            if not hrp then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y HumanoidRootPart.")
                return
            end

            local itemsFolder = workspace:FindFirstChild("Items")
            if not itemsFolder then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c 'Items' trong workspace.")
                return
            end

            local count = 0
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item:IsA("Model") and string.lower(item.Name):find(string.lower(itemName)) then
                    local part = item:FindFirstChildWhichIsA("BasePart") or (item:IsA("BasePart") and item)
                    if part then
                        part.CFrame = hrp.CFrame + Vector3.new(math.random(-7, 7), 0, math.random(-7, 7))
                        task.wait(0.02) -- ch·ªëng lag
                        count += 1
                    end
                end
            end

            if count > 0 then
                print(("[‚úÖ] Bring '%s' th√†nh c√¥ng (%d v·∫≠t ph·∫©m)!"):format(itemName, count))
            else
                warn(("[‚ö†Ô∏è] Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m '%s' trong map."):format(itemName))
            end
        end
    })
end


local Section = TabItem:AddSection({"Fuel"})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch v·∫≠t ph·∫©m mu·ªën t·∫°o n√∫t Bring
local fuelItems = {"Log", "Chair", "Coal", "Fuel Canister", "Oil Barrel"}

-- T·∫°o n√∫t Bring cho t·ª´ng v·∫≠t ph·∫©m (theo ki·ªÉu Fluent)
for _, itemName in ipairs(fuelItems) do
    TabItem:AddButton({
        Name = "Bring " .. itemName,
        Description = "H√∫t to√†n b·ªô v·∫≠t ph·∫©m '" .. itemName .. "' v·ªÅ quanh b·∫°n",
        Callback = function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")

            if not hrp then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y HumanoidRootPart.")
                return
            end

            local itemsFolder = workspace:FindFirstChild("Items")
            if not itemsFolder then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c 'Items' trong workspace.")
                return
            end

            local count = 0
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item:IsA("Model") and string.lower(item.Name):find(string.lower(itemName)) then
                    local part = item:FindFirstChildWhichIsA("BasePart") or (item:IsA("BasePart") and item)
                    if part then
                        part.CFrame = hrp.CFrame + Vector3.new(math.random(-7, 7), 0, math.random(-7, 7))
                        task.wait(0.02) -- ch·ªëng lag
                        count += 1
                    end
                end
            end

            if count > 0 then
                print(("[‚úÖ] Bring '%s' th√†nh c√¥ng (%d v·∫≠t ph·∫©m)!"):format(itemName, count))
            else
                warn(("[‚ö†Ô∏è] Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m '%s' trong map."):format(itemName))
            end
        end
    })
end



local Section = TabItem:AddSection({"Blue Print"})


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch v·∫≠t ph·∫©m mu·ªën t·∫°o n√∫t Bring
local BlueprintItems = {"Crafting Blueprint", "Defense Blueprint", "Furniture Blueprint"}

-- T·∫°o n√∫t Bring cho t·ª´ng v·∫≠t ph·∫©m (theo ki·ªÉu Fluent)
for _, itemName in ipairs(BlueprintItems) do
    TabItem:AddButton({
        Name = "Bring " .. itemName,
        Description = "H√∫t to√†n b·ªô v·∫≠t ph·∫©m '" .. itemName .. "' v·ªÅ quanh b·∫°n",
        Callback = function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")

            if not hrp then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y HumanoidRootPart.")
                return
            end

            local itemsFolder = workspace:FindFirstChild("Items")
            if not itemsFolder then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c 'Items' trong workspace.")
                return
            end

            local count = 0
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item:IsA("Model") and string.lower(item.Name):find(string.lower(itemName)) then
                    local part = item:FindFirstChildWhichIsA("BasePart") or (item:IsA("BasePart") and item)
                    if part then
                        part.CFrame = hrp.CFrame + Vector3.new(math.random(-7, 7), 0, math.random(-7, 7))
                        task.wait(0.02) -- ch·ªëng lag
                        count += 1
                    end
                end
            end

            if count > 0 then
                print(("[‚úÖ] Bring '%s' th√†nh c√¥ng (%d v·∫≠t ph·∫©m)!"):format(itemName, count))
            else
                warn(("[‚ö†Ô∏è] Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m '%s' trong map."):format(itemName))
            end
        end
    })
end





local Section = TabItem:AddSection({"Pelts"})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch v·∫≠t ph·∫©m mu·ªën t·∫°o n√∫t Bring
local PeltsItems = {"Bunny Foot", "Wolf Pelt", "Alpha Wolf Pelt", "Bear Pelt", "Arctic Fox Pelt", "Polar Bear Pelt"}

-- T·∫°o n√∫t Bring cho t·ª´ng v·∫≠t ph·∫©m (theo ki·ªÉu Fluent)
for _, itemName in ipairs(PeltsItems) do
    TabItem:AddButton({
        Name = "Bring " .. itemName,
        Description = "H√∫t to√†n b·ªô v·∫≠t ph·∫©m '" .. itemName .. "' v·ªÅ quanh b·∫°n",
        Callback = function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")

            if not hrp then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y HumanoidRootPart.")
                return
            end

            local itemsFolder = workspace:FindFirstChild("Items")
            if not itemsFolder then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c 'Items' trong workspace.")
                return
            end

            local count = 0
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item:IsA("Model") and string.lower(item.Name):find(string.lower(itemName)) then
                    local part = item:FindFirstChildWhichIsA("BasePart") or (item:IsA("BasePart") and item)
                    if part then
                        part.CFrame = hrp.CFrame + Vector3.new(math.random(-7, 7), 0, math.random(-7, 7))
                        task.wait(0.02) -- ch·ªëng lag
                        count += 1
                    end
                end
            end

            if count > 0 then
                print(("[‚úÖ] Bring '%s' th√†nh c√¥ng (%d v·∫≠t ph·∫©m)!"):format(itemName, count))
            else
                warn(("[‚ö†Ô∏è] Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m '%s' trong map."):format(itemName))
            end
        end
    })
end



local Section = TabItem:AddSection({"Junk"})


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch v·∫≠t ph·∫©m mu·ªën t·∫°o n√∫t Bring
local junkItems = {
    "Bolt", "Sheet Metal", "UFO Junk", "UFO Component", "Broken Fan", "Old Radio",
    "Broken Microwave", "Tyre", "Metal Chair", "Old Car Engine", "Washing Machine",
    "Cultist Experiment", "Cultist Prototype", "UFO Scrap", "Cultist Gem",
    "Gem of the Forest Fragment", "Feather", "Old Boot"
}

-- T·∫°o n√∫t Bring cho t·ª´ng v·∫≠t ph·∫©m (theo ki·ªÉu Fluent)
for _, itemName in ipairs(junkItems) do
    TabItem:AddButton({
        Name = "Bring " .. itemName,
        Description = "H√∫t to√†n b·ªô v·∫≠t ph·∫©m '" .. itemName .. "' v·ªÅ quanh b·∫°n",
        Callback = function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")

            if not hrp then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y HumanoidRootPart.")
                return
            end

            local itemsFolder = workspace:FindFirstChild("Items")
            if not itemsFolder then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c 'Items' trong workspace.")
                return
            end

            local count = 0
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item:IsA("Model") and string.lower(item.Name):find(string.lower(itemName)) then
                    local part = item:FindFirstChildWhichIsA("BasePart") or (item:IsA("BasePart") and item)
                    if part then
                        part.CFrame = hrp.CFrame + Vector3.new(math.random(-7, 7), 0, math.random(-7, 7))
                        task.wait(0.02) -- ch·ªëng lag
                        count += 1
                    end
                end
            end

            if count > 0 then
                print(("[‚úÖ] Bring '%s' th√†nh c√¥ng (%d v·∫≠t ph·∫©m)!"):format(itemName, count))
            else
                warn(("[‚ö†Ô∏è] Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m '%s' trong map."):format(itemName))
            end
        end
    })
end







local Section = TabItem:AddSection({"Food"})


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch v·∫≠t ph·∫©m mu·ªën t·∫°o n√∫t Bring
local foodItems = {
    "Cake", "Cooked Steak", "Cooked Morsel", "Ribs", "Salmon", "Cooked Salmon",
    "Cooked Ribs", "Mackerel", "Cooked Mackerel", "Steak", "Morsel", "Berry",
    "Carrot", "Stew", "Hearty Stew", "Corn", "Pumpkin", "Meat? Sandwich",
    "Seafood Chowder", "Steak Dinner", "Pumpkin Soup", "BBQ Ribs", "Carrot Cake",
    "Jar o' Jelly", "Clownfish", "Swordfish", "Jellyfish", "Char", "Eel", "Shark",
    "Cooked Clownfish", "Cooked Swordfish", "Cooked Jellyfish",
    "Cooked Char", "Cooked Eel", "Cooked Shark"
}

-- T·∫°o n√∫t Bring cho t·ª´ng v·∫≠t ph·∫©m (theo ki·ªÉu Fluent)
for _, itemName in ipairs(foodItems) do
    TabItem:AddButton({
        Name = "Bring " .. itemName,
        Description = "H√∫t to√†n b·ªô v·∫≠t ph·∫©m '" .. itemName .. "' v·ªÅ quanh b·∫°n",
        Callback = function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")

            if not hrp then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y HumanoidRootPart.")
                return
            end

            local itemsFolder = workspace:FindFirstChild("Items")
            if not itemsFolder then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c 'Items' trong workspace.")
                return
            end

            local count = 0
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item:IsA("Model") and string.lower(item.Name):find(string.lower(itemName)) then
                    local part = item:FindFirstChildWhichIsA("BasePart") or (item:IsA("BasePart") and item)
                    if part then
                        part.CFrame = hrp.CFrame + Vector3.new(math.random(-7, 7), 0, math.random(-7, 7))
                        task.wait(0.02) -- ch·ªëng lag
                        count += 1
                    end
                end
            end

            if count > 0 then
                print(("[‚úÖ] Bring '%s' th√†nh c√¥ng (%d v·∫≠t ph·∫©m)!"):format(itemName, count))
            else
                warn(("[‚ö†Ô∏è] Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m '%s' trong map."):format(itemName))
            end
        end
    })
end





local Section = TabItem:AddSection({"Equipment"})


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch v·∫≠t ph·∫©m mu·ªën t·∫°o n√∫t Bring
local equipmentItems = {
    "Revolver", "Rifle", "Revolver Ammo", "Rifle Ammo", "Giant Sack", "Good Sack",
    "Strong Axe", "Good Axe", "Frozen Shuriken", "Tactical Shotgun", "Snowball", "Kunai",
    "Leather Body", "Poison Armour", "Iron Body", "Thorn Body", "Riot Shield", "Alien Armour",
    "Red Key", "Blue Key", "Yellow Key", "Grey Key", "Frog Key", "Chili Seeds",
    "Flower Seeds", "Berry Seeds", "Firefly Seeds", "Old Rod", "Good Rod", "Strong Rod"
}

-- T·∫°o n√∫t Bring cho t·ª´ng v·∫≠t ph·∫©m (theo ki·ªÉu Fluent)
for _, itemName in ipairs(equipmentItems) do
    TabItem:AddButton({
        Name = "Bring " .. itemName,
        Description = "H√∫t to√†n b·ªô v·∫≠t ph·∫©m '" .. itemName .. "' v·ªÅ quanh b·∫°n",
        Callback = function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")

            if not hrp then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y HumanoidRootPart.")
                return
            end

            local itemsFolder = workspace:FindFirstChild("Items")
            if not itemsFolder then
                warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c 'Items' trong workspace.")
                return
            end

            local count = 0
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item:IsA("Model") and string.lower(item.Name):find(string.lower(itemName)) then
                    local part = item:FindFirstChildWhichIsA("BasePart") or (item:IsA("BasePart") and item)
                    if part then
                        part.CFrame = hrp.CFrame + Vector3.new(math.random(-7, 7), 0, math.random(-7, 7))
                        task.wait(0.02) -- ch·ªëng lag
                        count += 1
                    end
                end
            end

            if count > 0 then
                print(("[‚úÖ] Bring '%s' th√†nh c√¥ng (%d v·∫≠t ph·∫©m)!"):format(itemName, count))
            else
                warn(("[‚ö†Ô∏è] Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m '%s' trong map."):format(itemName))
            end
        end
    })
end



---------------------------------------------------------------------------------
-- Ph·∫ßn Teleport
---------------------------------------------------------------------------------

TabTeleport:AddButton({
    Name = "Teleport to Camp",
    Description = "D·ªãch chuy·ªÉn ƒë·∫øn khu c·∫Øm tr·∫°i",
    Callback = function()
        pcall(function()
            local player = game:GetService("Players").LocalPlayer
            local char = player.Character or player.CharacterAdded:Wait()
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            hrp.CFrame = CFrame.new(
                13.287363052368164, 3.999999761581421, 0.36212217807769775,
                0.6022269129753113, -2.275036159460342e-08, 0.7983249425888062,
                6.430457055728311e-09, 1, 2.364672191390582e-08,
                -0.7983249425888062, -9.1070981866892e-09, 0.6022269129753113
            )
        end)
    end
})

TabTeleport:AddButton({
    Name = "Teleport to Stronghold",
    Description = "D·ªãch chuy·ªÉn ƒë·∫øn Stronghold",
    Callback = function()
        pcall(function()
            local player = game:GetService("Players").LocalPlayer
            local char = player.Character or player.CharacterAdded:Wait()
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local map = workspace:FindFirstChild("Map")
            if not map then return end

            local stronghold = map:FindFirstChild("Landmarks")
                and map.Landmarks:FindFirstChild("Stronghold")
                and map.Landmarks.Stronghold:FindFirstChild("Functional")
                and map.Landmarks.Stronghold.Functional:FindFirstChild("EntryDoors")
                and map.Landmarks.Stronghold.Functional.EntryDoors:FindFirstChild("DoorRight")
                and map.Landmarks.Stronghold.Functional.EntryDoors.DoorRight:FindFirstChild("Model")

            if stronghold then
                local children = stronghold:GetChildren()
                local destination = children[5]
                if destination and destination:IsA("BasePart") then
                    hrp.CFrame = destination.CFrame + Vector3.new(0, 5, 0)
                end
            else
                warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Stronghold trong b·∫£n ƒë·ªì!")
            end
        end)
    end
})

TabTeleport:AddButton({
    Name = "Teleport to Safe Zone",
    Description = "T·∫°o Safe Zone tr√™n kh√¥ng v√† d·ªãch chuy·ªÉn ƒë·∫øn ƒë√≥",
    Callback = function()
        if not workspace:FindFirstChild("SafeZonePart") then
            local createpart = Instance.new("Part")
            createpart.Name = "SafeZonePart"
            createpart.Size = Vector3.new(30, 3, 30)
            createpart.Position = Vector3.new(0, 350, 0)
            createpart.Anchored = true
            createpart.CanCollide = true
            createpart.Transparency = 0.8
            createpart.Color = Color3.fromRGB(255, 0, 0)
            createpart.Parent = workspace
        end
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        hrp.CFrame = CFrame.new(0, 360, 0)
    end
})

TabTeleport:AddButton({
    Name = "Teleport to Trader (Bunny Foot)",
    Description = "D·ªãch chuy·ªÉn ƒë·∫øn khu v·ª±c th∆∞∆°ng nh√¢n Bunny Foot",
    Callback = function()
        local pos = Vector3.new(-37.08, 3.98, -16.33)
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        hrp.CFrame = CFrame.new(pos)
    end
})

local Section = TabTeleport:AddSection({"Child"})


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

-- Danh s√°ch Lost Child
local lostChildNames = {
    ["Lost Child"] = true,
    ["Lost Child2"] = true,
    ["Lost Child3"] = true,
    ["Lost Child4"] = true
}

-- ‚ö†Ô∏è V√πng lo·∫°i tr·ª´ (center v√† b√°n k√≠nh)
local forbiddenCenter = Vector3.new(0.40, 8.22, 0.10)
local forbiddenRadius = 100

-- üîç H√†m t√¨m Lost Child g·∫ßn nh·∫•t (kh√¥ng n·∫±m trong v√πng c·∫•m)
local function findNearestLostChild()
    local character = player.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, nearestDist

    for _, obj in ipairs(workspace:GetDescendants()) do
        if lostChildNames[obj.Name] and obj:IsA("Model") then
            local part = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                local distToPlayer = (hrp.Position - part.Position).Magnitude
                local distToForbidden = (forbiddenCenter - part.Position).Magnitude

                -- Ch·ªâ ch·ªçn n·∫øu kh√¥ng n·∫±m trong v√πng lo·∫°i tr·ª´
                if distToForbidden > forbiddenRadius then
                    if not nearest or distToPlayer < nearestDist then
                        nearest = part
                        nearestDist = distToPlayer
                    end
                end
            end
        end
    end

    return nearest
end

-- üöÄ H√†m teleport
local function teleportToNearestLostChild()
    local nearest = findNearestLostChild()
    if nearest then
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = nearest.CFrame + Vector3.new(0, 5, 0)
            print("[‚úÖ] Teleported to nearest Lost Child:", nearest.Name)
        end
    else
        warn("[‚ö†Ô∏è] No valid Lost Child found (maybe all in restricted zone).")
    end
end

-- üß© Button teleport 1 l·∫ßn
TabTeleport:AddButton({
    Name = "Teleport to Lost Child",
    Description = "T√¨m v√† d·ªãch chuy·ªÉn ƒë·∫øn Lost Child g·∫ßn nh·∫•t",
    Callback = teleportToNearestLostChild
})

-- üîÅ Toggle Auto Teleport
local autoTPEnabled = false
local autoTPConnection

TabTeleport:AddToggle({
    Name = "Auto Teleport To Lost Child",
    Description = "T·ª± ƒë·ªông d·ªãch chuy·ªÉn khi Lost Child xu·∫•t hi·ªán",
    Default = false,
    Callback = function(Value)
        autoTPEnabled = Value

        if autoTPEnabled then
            print("[üåÄ] Auto Teleport Lost Child: ON")

            autoTPConnection = RunService.Heartbeat:Connect(function()
                local nearest = findNearestLostChild()
                if nearest then
                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = nearest.CFrame + Vector3.new(0, 5, 0)
                    end
                end
                task.wait(0.5)
            end)

        else
            print("[üõë] Auto Teleport Lost Child: OFF")
            if autoTPConnection then
                autoTPConnection:Disconnect()
                autoTPConnection = nil
            end
        end
    end
})


local Section = TabTeleport:AddSection({"Chest"})


-- üß∞ Teleport to Chest (Fluent Button Style)
local chestList = {
    "Item Chest",
    "Item Chest2",
    "Item Chest3",
    "Item Chest4",
    "Item Chest5",
    "Item Chest6"
}

local selectedChest = nil

-- Dropdown ch·ªçn r∆∞∆°ng
TabTeleport:AddDropdown({
    Name = "Select Chest",
    Description = "Ch·ªçn r∆∞∆°ng b·∫°n mu·ªën d·ªãch chuy·ªÉn ƒë·∫øn",
    Options = chestList,
    Default = {},
    MultiSelect = false,
    Callback = function(option)
        selectedChest = option
    end
})

-- N√∫t d·ªãch chuy·ªÉn
TabTeleport:AddButton({
    Name = "Teleport to Chest",
    Description = "D·ªãch chuy·ªÉn ƒë·∫øn r∆∞∆°ng ƒë∆∞·ª£c ch·ªçn",
    Callback = function()
        if not selectedChest then
            warn("[‚ö†Ô∏è] B·∫°n ch∆∞a ch·ªçn r∆∞∆°ng n√†o ƒë·ªÉ d·ªãch chuy·ªÉn.")
            return
        end

        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local itemsFolder = workspace:FindFirstChild("Items")
        if not itemsFolder then
            warn("[‚ùå] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c 'Items' trong workspace.")
            return
        end

        local targetChest = itemsFolder:FindFirstChild(selectedChest)
        if targetChest and targetChest:IsA("Model") and targetChest.PrimaryPart then
            -- D·ªãch chuy·ªÉn ƒë·∫øn chest
            hrp.CFrame = targetChest.PrimaryPart.CFrame + Vector3.new(0, 2, 0)
            print("[‚úÖ] ƒê√£ d·ªãch chuy·ªÉn ƒë·∫øn: " .. selectedChest)
        else
            warn("[‚ùå] Kh√¥ng t√¨m th·∫•y " .. selectedChest .. " ho·∫∑c n√≥ kh√¥ng c√≥ PrimaryPart.")
        end
    end
})





------------------------------------------------------------
-- üíé TELEPORT TO STRONGHOLD DIAMOND CHEST
------------------------------------------------------------
TabTeleport:AddButton({
    Name = "Teleport to Diamond Chest",
    Description = "D·ªãch chuy·ªÉn ƒë·∫øn Stronghold Diamond Chest trong Items",
    Callback = function()
        local items = workspace:FindFirstChild("Items")
        if not items then
            warn("[‚ùå] Items folder not found!")
            return
        end

        local chest = items:FindFirstChild("Stronghold Diamond Chest")
        if not chest then
            warn("[‚ùå] Stronghold Diamond Chest not found!")
            return
        end

        local chestLid = chest:FindFirstChild("ChestLid")
        if not chestLid then
            warn("[‚ùå] ChestLid not found!")
            return
        end

        local diamondchest = chestLid:FindFirstChild("Meshes/diamondchest_Cube.002")
        if not diamondchest then
            warn("[‚ùå] Diamond chest mesh not found!")
            return
        end

        local player = game.Players.LocalPlayer
        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = diamondchest.CFrame + Vector3.new(0, 5, 0)
            print("[‚úÖ] Teleported to Diamond Chest successfully!")
        else
            warn("[‚ùå] HumanoidRootPart not found!")
        end
    end
})




local Section = TabTeleport:AddSection({"Item"})

-- üì¶ TELEPORT TO ITEM
---------------------------------------------------
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local itemFolder = workspace:WaitForChild("Items")

local itemNames = {
    "Revolver", "Medkit", "Alien Chest", "Berry", "Bolt", "Broken Fan",
    "Carrot", "Coal", "Coin Stack", "Hologram Emitter", "Item Chest",
    "Laser Fence Blueprint", "Log", "Old Flashlight", "Old Radio",
    "Sheet Metal", "Bandage", "Rifle"
}

-- üß© L·∫•y part ch√≠nh c·ªßa model
local function getModelPart(model)
    if model.PrimaryPart then return model.PrimaryPart end
    for _, part in pairs(model:GetChildren()) do
        if part:IsA("BasePart") then
            return part
        end
    end
    return nil
end

-- üìú Dropdown ch·ªçn item
local selectedItem = itemNames[1]

TabTeleport:AddDropdown({
    Name = "Select Item",
    Description = "Ch·ªçn v·∫≠t ph·∫©m ƒë·ªÉ d·ªãch chuy·ªÉn t·ªõi",
    Options = itemNames,
    Default = selectedItem,
    Multi = false,
    AllowNone = true,
    Callback = function(selected)
        selectedItem = selected
    end
})

-- üß≠ N√∫t Teleport t·ªõi item ƒë√£ ch·ªçn
TabTeleport:AddButton({
    Name = "Teleport to Item",
    Description = "D·ªãch chuy·ªÉn ƒë·∫øn v·∫≠t ph·∫©m ƒë√£ ch·ªçn",
    Callback = function()
        if not selectedItem then
            warn("‚ö†Ô∏è B·∫°n ch∆∞a ch·ªçn v·∫≠t ph·∫©m n√†o.")
            return
        end

        local foundParts = {}
        for _, model in pairs(itemFolder:GetChildren()) do
            if model:IsA("Model") and model.Name == selectedItem then
                local part = getModelPart(model)
                if part then
                    table.insert(foundParts, part)
                end
            end
        end

        if #foundParts == 0 then
            warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m: " .. selectedItem)
            return
        end

        local targetPart = foundParts[math.random(1, #foundParts)]
        local char = localPlayer.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.CFrame = targetPart.CFrame + Vector3.new(0, 5, 0)
            end
        end
    end
})


---------------------------------------------------------------------------------
-- Ph·∫ßn Visual
---------------------------------------------------------------------------------

-- üåü ESP Player t·ª± h·ªìi ph·ª•c + nh·ªè g·ªçn + c√≥ Toggle trong TabVisual
-- ‚öôÔ∏è D√°n v√†o ph·∫ßn script GUI ch√≠nh

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- ‚öôÔ∏è C·∫•u h√¨nh
local CONFIG = {
	MaxDistance = 9999,
	UpdateRate = 0.08,
	Font = Enum.Font.GothamMedium,
	TextSize = 13,
	Offset = Vector3.new(0, 2, 0),
	TweenTime = 0.12,
	AutoReapplyRate = 2,
}

-- ‚ö° Tr·∫°ng th√°i ESP
local ESP_Enabled = false
local espMap = {}

-- üé® M√†u theo ph·∫ßn trƒÉm HP
local function healthColor(percent)
	if percent > 0.5 then
		return Color3.fromRGB(76, 217, 100)
	elseif percent > 0.25 then
		return Color3.fromRGB(255, 204, 0)
	else
		return Color3.fromRGB(255, 64, 64)
	end
end

-- üß± T·∫°o ESP GUI cho 1 nh√¢n v·∫≠t
local function createESPGuiForCharacter(character, player)
	if not character or not ESP_Enabled then return end
	local head = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
	if not head then return end
	if head:FindFirstChild("ESP_Billboard") then return head.ESP_Billboard end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "ESP_Billboard"
	billboard.Adornee = head
	billboard.AlwaysOnTop = true
	billboard.Size = UDim2.new(0, 150, 0, 40)
	billboard.StudsOffset = CONFIG.Offset
	billboard.Parent = head

	local bg = Instance.new("Frame", billboard)
	bg.Size = UDim2.new(1, 0, 1, 0)
	bg.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
	bg.BackgroundTransparency = 0.25
	bg.BorderSizePixel = 0
	Instance.new("UICorner", bg).CornerRadius = UDim.new(0, 8)
	local stroke = Instance.new("UIStroke", bg)
	stroke.Thickness = 1
	stroke.Transparency = 0.7

	local nameLabel = Instance.new("TextLabel", bg)
	nameLabel.Size = UDim2.new(1, -10, 0, 16)
	nameLabel.Position = UDim2.new(0, 5, 0, 2)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = CONFIG.Font
	nameLabel.TextSize = CONFIG.TextSize
	nameLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Text = player.Name

	local distLabel = Instance.new("TextLabel", bg)
	distLabel.Size = UDim2.new(0, 40, 0, 16)
	distLabel.Position = UDim2.new(1, -45, 0, 2)
	distLabel.BackgroundTransparency = 1
	distLabel.Font = CONFIG.Font
	distLabel.TextSize = CONFIG.TextSize - 1
	distLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	distLabel.TextXAlignment = Enum.TextXAlignment.Right
	distLabel.Text = "0m"

	local hpBarBG = Instance.new("Frame", bg)
	hpBarBG.Position = UDim2.new(0, 6, 0, 20)
	hpBarBG.Size = UDim2.new(1, -12, 0, 14)
	hpBarBG.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBG.BorderSizePixel = 0
	Instance.new("UICorner", hpBarBG).CornerRadius = UDim.new(0, 7)

	local hpFill = Instance.new("Frame", hpBarBG)
	hpFill.Size = UDim2.new(1, 0, 1, 0)
	hpFill.BackgroundColor3 = healthColor(1)
	hpFill.BorderSizePixel = 0
	Instance.new("UICorner", hpFill).CornerRadius = UDim.new(0, 7)

	local hpText = Instance.new("TextLabel", hpBarBG)
	hpText.Size = UDim2.new(1, 0, 1, 0)
	hpText.BackgroundTransparency = 1
	hpText.Font = CONFIG.Font
	hpText.TextSize = CONFIG.TextSize - 1
	hpText.TextColor3 = Color3.fromRGB(255, 255, 255)
	hpText.TextStrokeTransparency = 0.5
	hpText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	hpText.Text = "HP: 100%"
	hpText.TextXAlignment = Enum.TextXAlignment.Center
	hpText.TextYAlignment = Enum.TextYAlignment.Center

	return {
		Billboard = billboard,
		Head = head,
		Player = player,
		Character = character,
		HPFill = hpFill,
		HPText = hpText,
		DistLabel = distLabel,
	}
end

-- üîÅ C·∫≠p nh·∫≠t thanh m√°u
local function updateESP(esp, localRootPos)
	local char = esp.Character
	if not char or not char.Parent then
		if esp.Billboard then esp.Billboard:Destroy() end
		return
	end

	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local hp = math.clamp(humanoid.Health, 0, humanoid.MaxHealth)
	local percent = humanoid.MaxHealth > 0 and hp / humanoid.MaxHealth or 0
	local percentText = math.floor(percent * 100 + 0.5)

	esp.HPText.Text = string.format("HP: %d%%", percentText)
	local dist = (esp.Head.Position - localRootPos).Magnitude
	esp.DistLabel.Text = ("%dm"):format(math.floor(dist + 0.5))

	TweenService:Create(esp.HPFill, TweenInfo.new(CONFIG.TweenTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = UDim2.new(percent, 0, 1, 0),
		BackgroundColor3 = healthColor(percent)
	}):Play()
end

-- üßç‚Äç‚ôÇÔ∏è G·∫Øn ESP cho player
local function applyESPToPlayer(player)
	if player == LocalPlayer or not ESP_Enabled then return end

	local function setupCharacter(char)
		if not ESP_Enabled then return end
		local esp = createESPGuiForCharacter(char, player)
		if esp then
			espMap[player.UserId] = esp
			local humanoid = char:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.Died:Connect(function()
					task.wait(0.5)
					if espMap[player.UserId] then
						espMap[player.UserId].Billboard:Destroy()
						espMap[player.UserId] = nil
					end
				end)
			end
		end
	end

	if player.Character then setupCharacter(player.Character) end
	player.CharacterAdded:Connect(setupCharacter)
end

-- üß† T·ª± ph·ª•c h·ªìi ESP n·∫øu b·ªã m·∫•t
task.spawn(function()
	while task.wait(CONFIG.AutoReapplyRate) do
		if ESP_Enabled then
			for _, p in pairs(Players:GetPlayers()) do
				if p ~= LocalPlayer and p.Character then
					local head = p.Character:FindFirstChild("Head") or p.Character:FindFirstChild("HumanoidRootPart")
					if head and not head:FindFirstChild("ESP_Billboard") then
						applyESPToPlayer(p)
					end
				end
			end
		end
	end
end)

-- ‚è±Ô∏è C·∫≠p nh·∫≠t li√™n t·ª•c
RunService.Heartbeat:Connect(function()
	if not ESP_Enabled then return end
	local localRoot = LocalPlayer.Character and (LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character:FindFirstChild("Head"))
	if not localRoot then return end
	local pos = localRoot.Position
	for _, esp in pairs(espMap) do
		pcall(function() updateESP(esp, pos) end)
	end
end)

-- üü¢ Th√™m toggle v√†o TabVisual
TabVisual:AddToggle({
	Name = "ESP Player",
	Description = "Hi·ªÉn th·ªã v·ªã tr√≠, m√°u c·ªßa player",
	Default = false,
	Callback = function(value)
		ESP_Enabled = value
		if value then
			for _, plr in pairs(Players:GetPlayers()) do
				if plr ~= LocalPlayer then
					applyESPToPlayer(plr)
				end
			end
		else
			for _, esp in pairs(espMap) do
				if esp.Billboard then esp.Billboard:Destroy() end
			end
			espMap = {}
		end
	end
})





------------------------------------------------
-- ‚öôÔ∏è ESP ITEM (Drawing + Highlight)
------------------------------------------------

do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- üéØ Danh s√°ch item c·∫ßn ESP
local allowedItems = {
    ["Bandage"] = true, ["Bolt"] = true, ["Broken Fan"] = true, ["Broken Microwave"] = true, ["Cake"] = true, ["Carrot"] = true,
    ["Chair"] = true, ["Coal"] = true, ["Coin Stack"] = true, ["Cooked Morsel"] = true, ["Cooked Steak"] = true, ["Fuel Canister"] = true,
    ["Iron Body"] = true, ["Leather Armor"] = true, ["Log"] = true, ["MadKit"] = true, ["Metal Chair"] = true, ["MedKit"] = true,
    ["Old Car Engine"] = true, ["Old Flashlight"] = true, ["Old Radio"] = true, ["Revolver"] = true, ["Revolver Ammo"] = true,
    ["Rifle"] = true, ["Rifle Ammo"] = true, ["Morsel"] = true, ["Sheet Metal"] = true, ["Steak"] = true, ["Tyre"] = true,
    ["Washing Machine"] = true, ["Cultist Gem"] = true, ["Gem of the Forest Fragment"] = true, ["Frozen Shuriken"] = true,
    ["Tactical Shotgun"] = true, ["Snowball"] = true, ["Kunai"] = true
}

------------------------------------------------
-- üì¶ Bi·∫øn l∆∞u
------------------------------------------------
local drawingsItem = {}
local espConnectionItem
local addedConnItem, removedConnItem
local espItemEnabled = false

------------------------------------------------
-- üß© H√†m ch√≠nh
------------------------------------------------
local function createOrRepairESPItem(obj, drawings, color)
	if not obj or not obj:IsA("BasePart") then return end
	local data = drawings[obj]

	if not data then
		local text = Drawing.new("Text")
		text.Size = 14
		text.Center = true
		text.Outline = true
		text.Visible = false
		text.Color = color

		local highlight = Instance.new("Highlight")
		highlight.Adornee = obj
		highlight.FillColor = color
		highlight.OutlineColor = color
		highlight.FillTransparency = 0.7
		highlight.OutlineTransparency = 0
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.Enabled = true
		highlight.Parent = obj

		drawings[obj] = { text = text, highlight = highlight }
		return
	end

	if not data.text then
		local text = Drawing.new("Text")
		text.Size = 14
		text.Center = true
		text.Outline = true
		text.Visible = false
		text.Color = color
		data.text = text
	end

	if (not data.highlight) or (not data.highlight.Parent) then
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
		local highlight = Instance.new("Highlight")
		highlight.Adornee = obj
		highlight.FillColor = color
		highlight.OutlineColor = color
		highlight.FillTransparency = 0.7
		highlight.OutlineTransparency = 0
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.Enabled = true
		highlight.Parent = obj
		data.highlight = highlight
	else
		data.highlight.Adornee = obj
		data.highlight.Enabled = true
	end
end

local function removeESPItem(obj, drawings)
	local data = drawings[obj]
	if data then
		pcall(function() if data.text then data.text:Remove() end end)
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
	end
	drawings[obj] = nil
end

local function scanWorkspaceForItems(allowedList, drawings, color)
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and allowedList[obj.Name] then
			createOrRepairESPItem(obj, drawings, color)
		end
	end
end

------------------------------------------------
-- ‚ñ∂Ô∏è B·∫≠t ESP
------------------------------------------------
local function startESPItem()
	if espConnectionItem then return end
	local COLOR = Color3.fromRGB(255, 255, 0)
	scanWorkspaceForItems(allowedItems, drawingsItem, COLOR)

	espConnectionItem = RunService.RenderStepped:Connect(function()
		for obj, data in pairs(drawingsItem) do
			createOrRepairESPItem(obj, drawingsItem, COLOR)
			data = drawingsItem[obj]

			if obj and obj.Parent then
				local pos, onScreen = Camera:WorldToViewportPoint(obj.Position + Vector3.new(0, 1.5, 0))
				local dist = (obj.Position - Camera.CFrame.Position).Magnitude
				if data.text then
					data.text.Text = string.format("%s [%.0fm]", obj.Name, dist)
					data.text.Position = Vector2.new(pos.X, pos.Y)
					data.text.Visible = onScreen
				end
				if data.highlight then
					data.highlight.Enabled = true
				end
			else
				if data.text then data.text.Visible = false end
				if data.highlight then data.highlight.Enabled = false end
			end
		end
	end)

	addedConnItem = workspace.DescendantAdded:Connect(function(obj)
		if obj:IsA("BasePart") and allowedItems[obj.Name] then
			createOrRepairESPItem(obj, drawingsItem, COLOR)
		end
	end)

	removedConnItem = workspace.DescendantRemoving:Connect(function(obj)
		if drawingsItem[obj] then
			removeESPItem(obj, drawingsItem)
		end
	end)
end

------------------------------------------------
-- ‚èπÔ∏è T·∫Øt ESP
------------------------------------------------
local function stopESPItem()
	if espConnectionItem then espConnectionItem:Disconnect() end
	if addedConnItem then addedConnItem:Disconnect() end
	if removedConnItem then removedConnItem:Disconnect() end
	for _, data in pairs(drawingsItem) do
		pcall(function() if data.text then data.text:Remove() end end)
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
	end
	table.clear(drawingsItem)
	espConnectionItem, addedConnItem, removedConnItem = nil, nil, nil
end

------------------------------------------------
-- üéöÔ∏è N√∫t toggle trong TabVisual
------------------------------------------------
TabVisual:AddToggle({
	Name = "ESP Item",
	Description = "Hi·ªÉn th·ªã v·ªã tr√≠ v·∫≠t ph·∫©m",
	Default = false,
	Callback = function(Value)
		espItemEnabled = Value
		if Value then
			startESPItem()
		else
			stopESPItem()
		end
	end
})
end



------------------------------------------------
-- ‚öôÔ∏è ESP ITEM (Drawing + Highlight m√†u v√†ng gold)
------------------------------------------------

do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- üéØ Danh s√°ch item c·∫ßn ESP
local allowedItemsGold = {
    ["Revolver"] = true, ["Rifle"] = true, ["Revolver Ammo"] = true, ["Rifle Ammo"] = true,
    ["Giant Sack"] = true, ["Good Sack"] = true,
    ["Strong Axe"] = true, ["Good Axe"] = true,
    ["Frozen Shuriken"] = true, ["Tactical Shotgun"] = true, ["Snowball"] = true, ["Kunai"] = true,
    ["Leather Body"] = true, ["Poison Armour"] = true, ["Iron Body"] = true, ["Thorn Body"] = true,
    ["Riot Shield"] = true, ["Alien Armour"] = true,
    ["Red Key"] = true, ["Blue Key"] = true, ["Yellow Key"] = true, ["Grey Key"] = true, ["Frog Key"] = true,
    ["Chili Seeds"] = true, ["Flower Seeds"] = true, ["Berry Seeds"] = true, ["Firefly Seeds"] = true,
    ["Old Rod"] = true, ["Good Rod"] = true, ["Strong Rod"] = true,
}

------------------------------------------------
-- üì¶ Bi·∫øn l∆∞u
------------------------------------------------
local drawingsGold = {}
local espConnectionGold
local addedConnGold, removedConnGold
local espGoldEnabled = false

------------------------------------------------
-- üß© H√†m t·∫°o ESP item
------------------------------------------------
local function createOrRepairESPGold(model, drawings, color)
	if not model or not model:IsA("Model") then return end
	local root = model:FindFirstChild("Handle") or model:FindFirstChildWhichIsA("BasePart")
	if not root then return end

	local data = drawings[model]
	if not data then
		local text = Drawing.new("Text")
		text.Size = 14
		text.Center = true
		text.Outline = true
		text.Visible = false
		text.Color = color

		local highlight = Instance.new("Highlight")
		highlight.Adornee = model
		highlight.FillColor = color
		highlight.OutlineColor = color
		highlight.FillTransparency = 0.7
		highlight.OutlineTransparency = 0
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.Enabled = true
		highlight.Parent = model

		drawings[model] = { text = text, highlight = highlight }
		return
	end

	if not data.text then
		local text = Drawing.new("Text")
		text.Size = 14
		text.Center = true
		text.Outline = true
		text.Visible = false
		text.Color = color
		data.text = text
	end

	if (not data.highlight) or (not data.highlight.Parent) then
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
		local highlight = Instance.new("Highlight")
		highlight.Adornee = model
		highlight.FillColor = color
		highlight.OutlineColor = color
		highlight.FillTransparency = 0.7
		highlight.OutlineTransparency = 0
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.Enabled = true
		highlight.Parent = model
		data.highlight = highlight
	else
		data.highlight.Adornee = model
		data.highlight.Enabled = true
	end
end

------------------------------------------------
-- ‚ùå Xo√° ESP item
------------------------------------------------
local function removeESPGold(model, drawings)
	local data = drawings[model]
	if data then
		pcall(function() if data.text then data.text:Remove() end end)
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
	end
	drawings[model] = nil
end

------------------------------------------------
-- üîç Qu√©t workspace t√¨m item
------------------------------------------------
local function scanWorkspaceForGoldItems(allowedList, drawings, color)
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Model") and allowedList[obj.Name] and (obj:FindFirstChild("Handle") or obj:FindFirstChildWhichIsA("BasePart")) then
			createOrRepairESPGold(obj, drawings, color)
		end
	end
end

------------------------------------------------
-- ‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu ESP
------------------------------------------------
local function startESPGold()
	if espConnectionGold then return end
	local COLOR = Color3.fromRGB(255, 215, 0) -- üíõ M√†u v√†ng gold
	scanWorkspaceForGoldItems(allowedItemsGold, drawingsGold, COLOR)

	espConnectionGold = RunService.RenderStepped:Connect(function()
		for model, data in pairs(drawingsGold) do
			createOrRepairESPGold(model, drawingsGold, COLOR)
			data = drawingsGold[model]

			if model.Parent then
				local root = model:FindFirstChild("Handle") or model:FindFirstChildWhichIsA("BasePart")
				if root then
					local pos, onScreen = Camera:WorldToViewportPoint(root.Position + Vector3.new(0, 1.5, 0))
					local dist = (root.Position - Camera.CFrame.Position).Magnitude

					if data.text then
						data.text.Text = string.format("%s [%.0fm]", model.Name, dist)
						data.text.Position = Vector2.new(pos.X, pos.Y)
						data.text.Visible = onScreen
					end

					if data.highlight then
						data.highlight.Enabled = true
					end
				end
			else
				if data.text then data.text.Visible = false end
				if data.highlight then data.highlight.Enabled = false end
			end
		end
	end)

	addedConnGold = workspace.DescendantAdded:Connect(function(obj)
		local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
		if model and allowedItemsGold[model.Name] then
			createOrRepairESPGold(model, drawingsGold, COLOR)
		end
	end)

	removedConnGold = workspace.DescendantRemoving:Connect(function(obj)
		local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
		if model and drawingsGold[model] then
			removeESPGold(model, drawingsGold)
		end
	end)
end

------------------------------------------------
-- ‚èπÔ∏è D·ª´ng ESP
------------------------------------------------
local function stopESPGold()
	if espConnectionGold then espConnectionGold:Disconnect() end
	if addedConnGold then addedConnGold:Disconnect() end
	if removedConnGold then removedConnGold:Disconnect() end
	for _, data in pairs(drawingsGold) do
		pcall(function() if data.text then data.text:Remove() end end)
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
	end
	table.clear(drawingsGold)
	espConnectionGold, addedConnGold, removedConnGold = nil, nil, nil
end

------------------------------------------------
-- üéöÔ∏è Toggle trong TabVisual
------------------------------------------------
TabVisual:AddToggle({
	Name = "ESP Weapon",
	Description = "Hi·ªÉn th·ªã v·ªã tr√≠ v√† kho·∫£ng c√°ch c·ªßa v≈© kh√≠",
	Default = false,
	Callback = function(Value)
		espGoldEnabled = Value
		if Value then
			startESPGold()
		else
			stopESPGold()
		end
	end
})
end




------------------------------------------------
-- ‚öôÔ∏è ESP MOB (Drawing + Highlight m√†u xanh l√°)
------------------------------------------------

do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- üéØ Danh s√°ch mob c·∫ßn ESP
local allowedMobs = {
	["Bunny"] = true, ["Wolf"] = true, ["Alpha Wolf"] = true, ["Bear"] = true,
	["Crossbow Cultist"] = true, ["Alien"] = true, ["Alien Elite"] = true,
	["Polar Bear"] = true, ["Arctic Fox"] = true, ["Mammoth"] = true,
	["Cultist"] = true, ["Cultist Melee"] = true, ["Cultist Crossbow"] = true,
	["Cultist Juggernaut"] = true,
}

------------------------------------------------
-- üì¶ Bi·∫øn l∆∞u
------------------------------------------------
local drawingsMob = {}
local espConnectionMob
local addedConnMob, removedConnMob
local espMobEnabled = false

------------------------------------------------
-- üß© H√†m t·∫°o / kh√¥i ph·ª•c ESP
------------------------------------------------
local function createOrRepairESPMob(model, drawings, color)
	if not model or not model:IsA("Model") then return end
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local data = drawings[model]
	if not data then
		local text = Drawing.new("Text")
		text.Size = 14
		text.Center = true
		text.Outline = true
		text.Visible = false
		text.Color = color

		local highlight = Instance.new("Highlight")
		highlight.Adornee = model
		highlight.FillColor = color
		highlight.OutlineColor = color
		highlight.FillTransparency = 0.7
		highlight.OutlineTransparency = 0
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.Enabled = true
		highlight.Parent = model

		drawings[model] = { text = text, highlight = highlight }
		return
	end

	if not data.text then
		local text = Drawing.new("Text")
		text.Size = 14
		text.Center = true
		text.Outline = true
		text.Visible = false
		text.Color = color
		data.text = text
	end

	if (not data.highlight) or (not data.highlight.Parent) then
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
		local highlight = Instance.new("Highlight")
		highlight.Adornee = model
		highlight.FillColor = color
		highlight.OutlineColor = color
		highlight.FillTransparency = 0.7
		highlight.OutlineTransparency = 0
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.Enabled = true
		highlight.Parent = model
		data.highlight = highlight
	else
		data.highlight.Adornee = model
		data.highlight.Enabled = true
	end
end

------------------------------------------------
-- ‚ùå Xo√° ESP
------------------------------------------------
local function removeESPMob(model, drawings)
	local data = drawings[model]
	if data then
		pcall(function() if data.text then data.text:Remove() end end)
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
	end
	drawings[model] = nil
end

------------------------------------------------
-- üîç Qu√©t workspace t√¨m mob
------------------------------------------------
local function scanWorkspaceForMobs(allowedList, drawings, color)
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Model") and allowedList[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
			createOrRepairESPMob(obj, drawings, color)
		end
	end
end

------------------------------------------------
-- ‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu ESP
------------------------------------------------
local function startESPMob()
	if espConnectionMob then return end
	local COLOR = Color3.fromRGB(0, 255, 0) -- üíö Xanh l√° c√¢y
	scanWorkspaceForMobs(allowedMobs, drawingsMob, COLOR)

	espConnectionMob = RunService.RenderStepped:Connect(function()
		for model, data in pairs(drawingsMob) do
			createOrRepairESPMob(model, drawingsMob, COLOR)
			data = drawingsMob[model]

			if model.Parent and model:FindFirstChild("HumanoidRootPart") then
				local hrp = model.HumanoidRootPart
				local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
				local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

				if data.text then
					data.text.Text = string.format("%s [%.0fm]", model.Name, dist)
					data.text.Position = Vector2.new(pos.X, pos.Y)
					data.text.Visible = onScreen
				end

				if data.highlight then
					data.highlight.Enabled = true
				end
			else
				if data.text then data.text.Visible = false end
				if data.highlight then data.highlight.Enabled = false end
			end
		end
	end)

	addedConnMob = workspace.DescendantAdded:Connect(function(obj)
		local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
		if model and allowedMobs[model.Name] then
			createOrRepairESPMob(model, drawingsMob, COLOR)
		end
	end)

	removedConnMob = workspace.DescendantRemoving:Connect(function(obj)
		local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
		if model and drawingsMob[model] then
			removeESPMob(model, drawingsMob)
		end
	end)
end

------------------------------------------------
-- ‚èπÔ∏è D·ª´ng ESP
------------------------------------------------
local function stopESPMob()
	if espConnectionMob then espConnectionMob:Disconnect() end
	if addedConnMob then addedConnMob:Disconnect() end
	if removedConnMob then removedConnMob:Disconnect() end
	for _, data in pairs(drawingsMob) do
		pcall(function() if data.text then data.text:Remove() end end)
		pcall(function() if data.highlight then data.highlight:Destroy() end end)
	end
	table.clear(drawingsMob)
	espConnectionMob, addedConnMob, removedConnMob = nil, nil, nil
end

------------------------------------------------
-- üéöÔ∏è Toggle trong TabVisual
------------------------------------------------
TabVisual:AddToggle({
	Name = "ESP Mob",
	Description = "Hi·ªÉn th·ªã v·ªã tr√≠ c·ªßa c√°c con v·∫≠t",
	Default = false,
	Callback = function(Value)
		espMobEnabled = Value
		if Value then
			startESPMob()
		else
			stopESPMob()
		end
	end
})
end





------------------------------------------------------------
-- üåà ESP LOST CHILD (7 M√ÄU)
------------------------------------------------------------

do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Danh s√°ch Lost Child
local lostChilds = {
    ["Lost Child"] = true,
    ["Lost Child2"] = true,
    ["Lost Child3"] = true,
    ["Lost Child4"] = true
}

-- B·ªô ch·ª©a ESP
local drawingsLostChild = {}
local espConnLostChild, addedConnLostChild, removedConnLostChild

-- ‚öôÔ∏è H√†m t·∫°o ho·∫∑c h·ªìi ph·ª•c ESP
local function createOrRepairESPLostChild(obj, drawings)
    if not obj then return end
    local data = drawings[obj]
    if not data then
        local part = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChild("Handle")
        if not part then return end

        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false

        -- Highlight
        local highlight = Instance.new("Highlight")
        highlight.Adornee = obj
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = obj

        drawings[obj] = {
            text = text,
            highlight = highlight,
            hue = math.random() -- m√†u ng·∫´u nhi√™n ban ƒë·∫ßu
        }
        return
    end

    -- H·ªìi ph·ª•c n·∫øu b·ªã m·∫•t
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        data.text = text
    end
    if (not data.highlight) or (not data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = obj
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = obj
        data.highlight = highlight
    end
end

-- ‚ùå Xo√° ESP
local function removeESPLostChild(obj, drawings)
    local data = drawings[obj]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawings[obj] = nil
end

-- üîç Qu√©t workspace ban ƒë·∫ßu
local function scanWorkspaceForLostChild(allowedList, drawings)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] then
            createOrRepairESPLostChild(obj, drawings)
        end
    end
end

-- üåà B·∫Øt ƒë·∫ßu ESP Lost Child
local function startESPLostChild()
    if espConnLostChild then return end

    scanWorkspaceForLostChild(lostChilds, drawingsLostChild)

    espConnLostChild = RunService.RenderStepped:Connect(function()
        for obj, data in pairs(drawingsLostChild) do
            createOrRepairESPLostChild(obj, drawingsLostChild)
            data = drawingsLostChild[obj]

            local part = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChild("Handle")
            if obj.Parent and part then
                -- C·∫≠p nh·∫≠t m√†u c·∫ßu v·ªìng
                data.hue = (data.hue + 0.005) % 1
                local color = Color3.fromHSV(data.hue, 1, 1)
                data.text.Color = color
                if data.highlight then
                    data.highlight.FillColor = color
                    data.highlight.OutlineColor = color
                end

                -- Hi·ªÉn th·ªã
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0, 1.5, 0))
                local dist = (part.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    data.text.Text = string.format("%s [%.0fm]", obj.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end)

    addedConnLostChild = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and lostChilds[model.Name] then
            createOrRepairESPLostChild(model, drawingsLostChild)
        end
    end)

    removedConnLostChild = workspace.DescendantRemoving:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsLostChild[model] then
            removeESPLostChild(model, drawingsLostChild)
        end
    end)
end

-- üõë D·ª´ng ESP Lost Child
local function stopESPLostChild()
    if espConnLostChild then espConnLostChild:Disconnect() end
    if addedConnLostChild then addedConnLostChild:Disconnect() end
    if removedConnLostChild then removedConnLostChild:Disconnect() end
    for _, data in pairs(drawingsLostChild) do
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    table.clear(drawingsLostChild)
    espConnLostChild, addedConnLostChild, removedConnLostChild = nil, nil, nil
end

-- üìå Toggle ESP Lost Child
TabVisual:AddToggle({
    Name = "ESP Lost Child",
    Description = "Hi·ªÉn th·ªã v·ªã tr√≠ c·ªßa tr·∫ª em m·∫•t t√≠ch",
    Default = false,
    Callback = function(Value)
        if Value then
            startESPLostChild()
        else
            stopESPLostChild()
        end
    end
})
end


------------------------------------------------------------
-- üß° ESP FOOD (Cam) ‚Äì highlight & text hi·ªÉn th·ªã kho·∫£ng c√°ch
------------------------------------------------------------

do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Danh s√°ch item th·ª©c ƒÉn c·∫ßn hi·ªÉn th·ªã ESP
local allowedFoods = {
    ["Cake"] = true, ["Cooked Steak"] = true, ["Cooked Morsel"] = true, ["Ribs"] = true,
    ["Salmon"] = true, ["Cooked Salmon"] = true, ["Cooked Ribs"] = true, ["Mackerel"] = true,
    ["Cooked Mackerel"] = true, ["Steak"] = true, ["Morsel"] = true, ["Berry"] = true,
    ["Carrot"] = true, ["Stew"] = true, ["Hearty Stew"] = true, ["Corn"] = true,
    ["Pumpkin"] = true, ["Meat? Sandwich"] = true, ["Seafood Chowder"] = true,
    ["Steak Dinner"] = true, ["Pumpkin Soup"] = true, ["BBQ Ribs"] = true,
    ["Carrot Cake"] = true, ["Jar o' Jelly"] = true, ["Clownfish"] = true,
    ["Swordfish"] = true, ["Jellyfish"] = true, ["Char"] = true, ["Eel"] = true, ["Shark"] = true,
    ["Cooked Clownfish"] = true, ["Cooked Swordfish"] = true, ["Cooked Jellyfish"] = true,
    ["Cooked Char"] = true, ["Cooked Eel"] = true, ["Cooked Shark"] = true,
}

-- B·ªô ch·ª©a ESP hi·ªán c√≥
local drawingsFood = {}
local espConnFood, addedConnFood, removedConnFood

-- H√†m t·∫°o ho·∫∑c kh√¥i ph·ª•c ESP
local function createOrRepairESPFood(obj, drawings, color)
    if not obj then return end
    local data = drawings[obj]
    if not data then
        -- X√°c ƒë·ªãnh v·ªã tr√≠ trung t√¢m
        local part = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChild("Handle")
        if not part then return end

        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color

        local highlight = Instance.new("Highlight")
        highlight.Adornee = obj
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = obj

        drawings[obj] = { text = text, highlight = highlight }
        return
    end

    -- N·∫øu ESP b·ªã m·∫•t th√¨ h·ªìi ph·ª•c
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color
        data.text = text
    end
    if (not data.highlight) or (not data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = obj
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = obj
        data.highlight = highlight
    end
end

-- Xo√° ESP
local function removeESPFood(obj, drawings)
    local data = drawings[obj]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawings[obj] = nil
end

-- Qu√©t workspace t·∫°o ESP ban ƒë·∫ßu
local function scanWorkspaceForFoods(allowedList, drawings, color)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] then
            createOrRepairESPFood(obj, drawings, color)
        end
    end
end

-- üî• B·∫Øt ƒë·∫ßu ESP
local function startESPFood()
    if espConnFood then return end

    local COLOR = Color3.fromRGB(255, 128, 0) -- üß° m√†u cam
    scanWorkspaceForFoods(allowedFoods, drawingsFood, COLOR)

    espConnFood = RunService.RenderStepped:Connect(function()
        for obj, data in pairs(drawingsFood) do
            createOrRepairESPFood(obj, drawingsFood, COLOR)
            data = drawingsFood[obj]

            local part = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChild("Handle")
            if obj.Parent and part then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0, 1.5, 0))
                local dist = (part.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    data.text.Text = string.format("%s [%.0fm]", obj.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end
                if data.highlight then
                    data.highlight.Enabled = true
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end)

    addedConnFood = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedFoods[model.Name] then
            createOrRepairESPFood(model, drawingsFood, COLOR)
        end
    end)

    removedConnFood = workspace.DescendantRemoving:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsFood[model] then
            removeESPFood(model, drawingsFood)
        end
    end)
end

-- üõë D·ª´ng ESP
local function stopESPFood()
    if espConnFood then espConnFood:Disconnect() end
    if addedConnFood then addedConnFood:Disconnect() end
    if removedConnFood then removedConnFood:Disconnect() end
    for _, data in pairs(drawingsFood) do
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    table.clear(drawingsFood)
    espConnFood, addedConnFood, removedConnFood = nil, nil, nil
end

-- üìå Toggle ESP Food
TabVisual:AddToggle({
    Name = "ESP Food",
    Description = "Hi·ªÉn th·ªã c√°c v·∫≠t ph·∫©m ƒÉn ƒë∆∞·ª£c",
    Default = false,
    Callback = function(Value)
        if Value then
            startESPFood()
        else
            stopESPFood()
        end
    end
})
end



------------------------------------------------------------
-- üíé ESP JUNK ITEMS (Xanh l∆°) ‚Äì highlight & text kho·∫£ng c√°ch
------------------------------------------------------------

do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Danh s√°ch ƒë·ªì ph·∫ø li·ªáu
local allowedJunkItems = {
    ["Bolt"] = true, ["Sheet Metal"] = true, ["UFO Junk"] = true, ["UFO Component"] = true,
    ["Broken Fan"] = true, ["Old Radio"] = true, ["Broken Microwave"] = true, ["Tyre"] = true,
    ["Metal Chair"] = true, ["Old Car Engine"] = true, ["Washing Machine"] = true,
    ["Cultist Experiment"] = true, ["Cultist Prototype"] = true, ["UFO Scrap"] = true,
    ["Cultist Gem"] = true, ["Gem of the Forest Fragment"] = true, ["Feather"] = true,
    ["Old Boot"] = true
}

-- B·ªô ch·ª©a ESP
local drawingsJunk = {}
local espConnJunk, addedConnJunk, removedConnJunk

-- H√†m t·∫°o ho·∫∑c h·ªìi ph·ª•c ESP
local function createOrRepairESPJunk(obj, drawings, color)
    if not obj then return end
    local data = drawings[obj]
    if not data then
        local part = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChild("Handle")
        if not part then return end

        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color

        local highlight = Instance.new("Highlight")
        highlight.Adornee = obj
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = obj

        drawings[obj] = { text = text, highlight = highlight }
        return
    end

    -- H·ªìi ph·ª•c n·∫øu m·∫•t
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color
        data.text = text
    end
    if (not data.highlight) or (not data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = obj
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = obj
        data.highlight = highlight
    end
end

-- Xo√° ESP
local function removeESPJunk(obj, drawings)
    local data = drawings[obj]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawings[obj] = nil
end

-- Qu√©t workspace t·∫°o ESP ban ƒë·∫ßu
local function scanWorkspaceForJunk(allowedList, drawings, color)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] then
            createOrRepairESPJunk(obj, drawings, color)
        end
    end
end

-- üî• B·∫Øt ƒë·∫ßu ESP Junk
local function startESPJunk()
    if espConnJunk then return end

    local COLOR = Color3.fromRGB(0, 255, 255) -- üíé xanh l∆°
    scanWorkspaceForJunk(allowedJunkItems, drawingsJunk, COLOR)

    espConnJunk = RunService.RenderStepped:Connect(function()
        for obj, data in pairs(drawingsJunk) do
            createOrRepairESPJunk(obj, drawingsJunk, COLOR)
            data = drawingsJunk[obj]

            local part = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChild("Handle")
            if obj.Parent and part then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0, 1.5, 0))
                local dist = (part.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    data.text.Text = string.format("%s [%.0fm]", obj.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end
                if data.highlight then
                    data.highlight.Enabled = true
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end)

    addedConnJunk = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedJunkItems[model.Name] then
            createOrRepairESPJunk(model, drawingsJunk, COLOR)
        end
    end)

    removedConnJunk = workspace.DescendantRemoving:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsJunk[model] then
            removeESPJunk(model, drawingsJunk)
        end
    end)
end

-- üõë D·ª´ng ESP Junk
local function stopESPJunk()
    if espConnJunk then espConnJunk:Disconnect() end
    if addedConnJunk then addedConnJunk:Disconnect() end
    if removedConnJunk then removedConnJunk:Disconnect() end
    for _, data in pairs(drawingsJunk) do
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    table.clear(drawingsJunk)
    espConnJunk, addedConnJunk, removedConnJunk = nil, nil, nil
end

-- üìå Toggle ESP Junk
TabVisual:AddToggle({
    Name = "ESP Junk",
    Description = "Hi·ªÉn th·ªã c√°c v·∫≠t ph·∫©m ph·∫ø li·ªáu",
    Default = false,
    Callback = function(Value)
        if Value then
            startESPJunk()
        else
            stopESPJunk()
        end
    end
})
end



------------------------------------------------------------
-- ‚ù§Ô∏è ESP HEAL ITEMS (ƒê·ªè)
------------------------------------------------------------

do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Danh s√°ch ƒë·ªì h·ªìi m√°u
local healItems = {
    ["Bandage"] = true,
    ["MedKit"] = true
}

-- B·ªô ch·ª©a ESP
local drawingsHeal = {}
local espConnHeal, addedConnHeal, removedConnHeal

-- H√†m t·∫°o ho·∫∑c h·ªìi ph·ª•c ESP
local function createOrRepairESPHeal(obj, drawings, color)
    if not obj then return end
    local data = drawings[obj]
    if not data then
        local part = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChild("Handle")
        if not part then return end

        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color

        local highlight = Instance.new("Highlight")
        highlight.Adornee = obj
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = obj

        drawings[obj] = { text = text, highlight = highlight }
        return
    end

    -- H·ªìi ph·ª•c n·∫øu b·ªã m·∫•t
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color
        data.text = text
    end
    if (not data.highlight) or (not data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = obj
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = obj
        data.highlight = highlight
    end
end

-- Xo√° ESP
local function removeESPHeal(obj, drawings)
    local data = drawings[obj]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawings[obj] = nil
end

-- Qu√©t workspace t·∫°o ESP ban ƒë·∫ßu
local function scanWorkspaceForHeal(allowedList, drawings, color)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] then
            createOrRepairESPHeal(obj, drawings, color)
        end
    end
end

-- üî• B·∫Øt ƒë·∫ßu ESP Heal
local function startESPHeal()
    if espConnHeal then return end

    local COLOR = Color3.fromRGB(255, 0, 0) -- ‚ù§Ô∏è ƒë·ªè
    scanWorkspaceForHeal(healItems, drawingsHeal, COLOR)

    espConnHeal = RunService.RenderStepped:Connect(function()
        for obj, data in pairs(drawingsHeal) do
            createOrRepairESPHeal(obj, drawingsHeal, COLOR)
            data = drawingsHeal[obj]

            local part = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChild("Handle")
            if obj.Parent and part then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0, 1.5, 0))
                local dist = (part.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    data.text.Text = string.format("%s [%.0fm]", obj.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end
                if data.highlight then
                    data.highlight.Enabled = true
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end)

    addedConnHeal = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and healItems[model.Name] then
            createOrRepairESPHeal(model, drawingsHeal, COLOR)
        end
    end)

    removedConnHeal = workspace.DescendantRemoving:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsHeal[model] then
            removeESPHeal(model, drawingsHeal)
        end
    end)
end

-- üõë D·ª´ng ESP Heal
local function stopESPHeal()
    if espConnHeal then espConnHeal:Disconnect() end
    if addedConnHeal then addedConnHeal:Disconnect() end
    if removedConnHeal then removedConnHeal:Disconnect() end
    for _, data in pairs(drawingsHeal) do
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    table.clear(drawingsHeal)
    espConnHeal, addedConnHeal, removedConnHeal = nil, nil, nil
end

-- üìå Toggle ESP Heal
TabVisual:AddToggle({
    Name = "ESP Heal",
    Description = "Hi·ªÉn th·ªã v·ªã tr√≠ ƒë·ªì h·ªìi m√°u",
    Default = false,
    Callback = function(Value)
        if Value then
            startESPHeal()
        else
            stopESPHeal()
        end
    end
})
end


---------------------------------------------------------------------------------
-- Ph·∫ßn Misc
---------------------------------------------------------------------------------

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- üåï FullBright Settings
local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end
    Lighting.Ambient = Color3.fromRGB(200, 200, 200) -- s√°ng nh·∫π
    Lighting.Brightness = 4 -- gi·∫£m ƒë·ªô s√°ng t·ª´ 10 ‚Üí 4
    Lighting.GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then
        fullBrightLoop:Disconnect()
        fullBrightLoop = nil
    end
    Lighting.Ambient = Color3.fromRGB(128, 128, 128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

-- ‚úÖ Toggle m·ªõi: FullBright
TabMisc:AddToggle({
    Name = "Full Bright",
    Description = "T·ª± ƒë·ªông l√†m s√°ng to√†n b·∫£n ƒë·ªì",
    Default = _G.FullBright or false,
    Callback = function(Value)
        _G.FullBright = Value
        fullBrightEnabled = Value
        if Value then
            enableFullBright()
        else
            disableFullBright()
        end
    end
})

-- üå´Ô∏è Remove Fog Settings
local fogEnabled = false
local fogLoop

local function removeFog()
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1, 1, 1)
    end
end

local function restoreFog()
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200, 200, 200)
    end
end

-- ‚úÖ Toggle m·ªõi: Remove Fog
TabMisc:AddToggle({
    Name = "Remove Fog",
    Description = "X√≥a s∆∞∆°ng m√π v√† l√†m t·∫ßm nh√¨n r√µ h∆°n",
    Default = _G.RemoveFog or false,
    Callback = function(Value)
        _G.RemoveFog = Value
        fogEnabled = Value
        if Value then
            removeFog()
            fogLoop = RunService.Heartbeat:Connect(removeFog)
        else
            if fogLoop then fogLoop:Disconnect() fogLoop = nil end
            restoreFog()
        end
    end
})



local Section = TabMisc:AddSection({"Bypass"})

local antiAfkEnabled = false
local antiAfkConnection

TabMisc:AddToggle({
    Name = "Anti AFK",
    Description = "NgƒÉn Roblox kick khi kh√¥ng ho·∫°t ƒë·ªông",
    Default = false,
    Callback = function(Value)
        antiAfkEnabled = Value

        if antiAfkEnabled then
            local VirtualUser = game:GetService("VirtualUser")
            local Players = game:GetService("Players")
            local player = Players.LocalPlayer

            antiAfkConnection = player.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)

            print("[‚úÖ] Anti AFK ƒë√£ b·∫≠t")
        else
            if antiAfkConnection then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end
            print("[‚õî] Anti AFK ƒë√£ t·∫Øt")
        end
    end
})


local Section = TabMisc:AddSection({"Anti Mob"})

-- üß© Services
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- ‚öôÔ∏è Bi·∫øn to√†n c·ª•c
local torchLoop
local escapeLoopOwl
local escapeLoopDeer

-- ü¶â / ü¶å Config
local ESCAPE_DISTANCE_OWL = 80
local ESCAPE_SPEED_OWL = 5

local ESCAPE_DISTANCE_DEER = 60
local ESCAPE_SPEED_DEER = 4


------------------------------------------------------------
-- ü¶å Auto Stun Deer (Need Flashlight)
------------------------------------------------------------
TabMisc:AddToggle({
    Name = "Auto Stun Deer",
    Description = "T·ª± ƒë·ªông l√†m Deer b·ªã cho√°ng (c·∫ßn c·∫ßm Flashlight)",
    Default = false,
    Callback = function(Value)
        if Value then
            torchLoop = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local remote = ReplicatedStorage:FindFirstChild("RemoteEvents")
                    if not remote then return end
                    local deerRemote = remote:FindFirstChild("DeerHitByTorch")
                    local deer = Workspace:FindFirstChild("Characters")
                        and Workspace.Characters:FindFirstChild("Deer")

                    if deerRemote and deer then
                        deerRemote:InvokeServer(deer)
                    end
                end)
                task.wait(0.1)
            end)
        else
            if torchLoop then
                torchLoop:Disconnect()
                torchLoop = nil
            end
        end
    end
})


------------------------------------------------------------
-- ü¶â Escape From Owl
------------------------------------------------------------
TabMisc:AddToggle({
    Name = "Escape From Owl",
    Description = "T·ª± ƒë·ªông tr√°nh xa Owl khi ·ªü g·∫ßn",
    Default = false,
    Callback = function(Value)
        if Value then
            escapeLoopOwl = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local characters = Workspace:FindFirstChild("Characters")
                    if not characters then return end
                    local owl = characters:FindFirstChild("Owl")

                    if owl and owl:FindFirstChild("HumanoidRootPart") then
                        local myPos = HumanoidRootPart.Position
                        local owlPos = owl.HumanoidRootPart.Position
                        local distance = (myPos - owlPos).Magnitude

                        if distance < ESCAPE_DISTANCE_OWL then
                            local direction = (myPos - owlPos).Unit
                            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + direction * ESCAPE_SPEED_OWL
                        end
                    end
                end)
            end)
        else
            if escapeLoopOwl then
                escapeLoopOwl:Disconnect()
                escapeLoopOwl = nil
            end
        end
    end
})


------------------------------------------------------------
-- ü¶å Escape From Deer
------------------------------------------------------------
TabMisc:AddToggle({
    Name = "Escape From Deer",
    Description = "T·ª± ƒë·ªông tr√°nh xa Deer khi ·ªü g·∫ßn",
    Default = false,
    Callback = function(Value)
        if Value then
            escapeLoopDeer = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local characters = Workspace:FindFirstChild("Characters")
                    if not characters then return end
                    local deer = characters:FindFirstChild("Deer")

                    if deer and deer:FindFirstChild("HumanoidRootPart") then
                        local myPos = HumanoidRootPart.Position
                        local deerPos = deer.HumanoidRootPart.Position
                        local distance = (myPos - deerPos).Magnitude

                        if distance < ESCAPE_DISTANCE_DEER then
                            local direction = (myPos - deerPos).Unit
                            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + direction * ESCAPE_SPEED_DEER
                        end
                    end
                end)
            end)
        else
            if escapeLoopDeer then
                escapeLoopDeer:Disconnect()
                escapeLoopDeer = nil
            end
        end
    end
})

local Section = TabMisc:AddSection({"Show"})


-- ‚öôÔ∏è FPS + Ping Drawing Setup
local showFPS = true
local showPing = true

local fpsText = Drawing.new("Text")
fpsText.Size = 16
fpsText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 10)
fpsText.Color = Color3.fromRGB(0, 255, 0)
fpsText.Center = false
fpsText.Outline = true
fpsText.Visible = showFPS

local msText = Drawing.new("Text")
msText.Size = 16
msText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 30)
msText.Color = Color3.fromRGB(0, 255, 0)
msText.Center = false
msText.Outline = true
msText.Visible = showPing

local fpsCounter = 0
local fpsLastUpdate = tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - fpsLastUpdate >= 1 then
        -- üßÆ Update FPS
        if showFPS then
            fpsText.Text = "FPS: " .. tostring(fpsCounter)
            fpsText.Visible = true
        else
            fpsText.Visible = false
        end

        -- üåê Update Ping
        if showPing then
            local pingStat = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]
            local ping = pingStat and math.floor(pingStat:GetValue()) or 0
            msText.Text = "Ping: " .. ping .. " ms"

            if ping <= 60 then
                msText.Color = Color3.fromRGB(0, 255, 0)
            elseif ping <= 120 then
                msText.Color = Color3.fromRGB(255, 165, 0)
            else
                msText.Color = Color3.fromRGB(255, 0, 0)
            end

            msText.Visible = true
        else
            msText.Visible = false
        end

        fpsCounter = 0
        fpsLastUpdate = tick()
    end
end)

-- ‚úÖ Fluent GUI Toggle format m·ªõi
TabMisc:AddToggle({
    Name = "Show FPS",
    Description = "Hi·ªÉn th·ªã s·ªë khung h√¨nh (FPS) tr√™n m√†n h√¨nh",
    Default = _G.ShowFPS or true,
    Callback = function(Value)
        _G.ShowFPS = Value
        showFPS = Value
        fpsText.Visible = Value
    end
})

TabMisc:AddToggle({
    Name = "Show Ping",
    Description = "Hi·ªÉn th·ªã ƒë·ªô tr·ªÖ m·∫°ng (Ping) tr√™n m√†n h√¨nh",
    Default = _G.ShowPing or true,
    Callback = function(Value)
        _G.ShowPing = Value
        showPing = Value
        msText.Visible = Value
    end
})

